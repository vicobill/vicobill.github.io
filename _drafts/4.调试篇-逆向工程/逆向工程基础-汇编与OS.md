逆向工程原则：
- 绝不要根据文件的扩展名来确定文件的类型。
- 绝不要*完全*相信任何工具所提供的结果。
- 一切皆有特征。
- 一切皆是文件，可执行文件也只是文件而已。

工具箱：
- linux.file : 根据文件头幻数确定文件类型
- linux.nm: 列出目标文件的符号
- linux.ldd/objdump: 列出可执行文件依赖的动态链接库(VS dumpbin /dependents)
- linux.c++filt: 重新还原C++ mangled的函数名称
- linux.strings： 提取文件中的字符串内容。
- nasm.ndisasm: 流式反汇编，可从指定偏移量开始反汇编。
- vs.ildasm,vs.ilasm: il反汇编和汇编器。

# 汇编
## 寄存器

寄存器一般用来保存程序中间结果，为随后指令快速提供操作数,从而避免把中间结果存入内存，再读取内存的操作。（寄存器的存取速度比内存快）

16位汇编寄存器组：
- 4个数据寄存器：ax,bx,cx,dx
- 2个变址和指针寄存器：si, di
- 2个指针寄存器：sp,bp
- 4个段寄存器：es,cs,ss,ds
- 1个指令指针寄存器：ip
- 1个标志寄存器：flags

32位汇编寄存器组：
- 4个数据寄存器：eax,ebx,ecx,edx
- 2个变址和指针寄存器：esi, edi
- 2个指针寄存器：esp,ebp
- 6个段寄存器：es,cs,ss,ds; fs,gs
- 1个指令指针寄存器：eip
- 1个标志寄存器：eflags


64位汇编寄存器组：
- 4个数据寄存器：rax,rbx,rcx,rdx
- 8个新增通用寄存器：r8..15
- 2个变址和指针寄存器：rsi, rdi
- 2个指针寄存器：rsp,rbp
- 6个段寄存器：es,cs,ss,ds; fs,gs
- 1个指令指针寄存器：rip
- 1个标志寄存器：eflags

浮点寄存器：
- 8个浮点寄存器：mmx0..7
- 16个SSE指令寄存器：xmmx0..15

寄存器常用于：
> (通用寄存器的用途是灵活的，并不局限于一种用途，以下所列为通常用途)

|寄存器|常用于|
|---|---|
| rax | 返回值 |
| rbx | 被调函数保存 | 
| rcx | 第 4 参数 |
| rdx | 第 3 参数 | 
| rsi | 第 2 参数 |
| rdi | 第 1 参数 |
| rbp | 被调函数保存 | 
| rsp | 栈指针 |
| r8 | 第 5 参数 |
| r9  | 第 6 参数 | 
| r10  | 主调函数保存 | 
| r11  | 主调函数保存 | 
| r12  | 被调函数保存 | 
| r13  | 被调函数保存 | 
| r14  | 被调函数保存 | 
| r15  | 被调函数保存 | 

状态寄存器：CPSR，具有条件标志位：
|标志|全拼|作用| 条件码助记符 |
|---|---|---|---|
| N | Negative | 表示运算结果是否为负数| 负数 MI(minus: *N=1*) <br> 正数和零 PL(plus: *N=0*) |
| Z | Zero | 表示结果是否为0 | 相等 EQ(equal:*Z=1*) <br> 不等 NE(not equal: *Z=0*) <br> 无符号大于 HI(high: *C=1,Z=0*) <br> 无符号小于等于 LS(lower or same: *C=0,Z=1*) |
| C | Carry | 无符号运算是否有溢出（进位） | 无符号数大于或等于 CS/HS(carry set / high or same : *C=1*) <BR> 无符号数小于 CC/LO(carry clear / lower: *C=0*) |
| V | oVerflow | 有符号运算是否有溢出 | 溢出 VS(overflow set: *V=1*) <br> 无溢出 VC(overflow clear: *V=0*) <br> 有符号大于等于 GE(greater or equal: *N=V*) <br> 有符号小于LT(less than: *N!=V*) <br> 有符号大于GT(greater than: *Z=0,N=V*) 有符号小于等于 LE(less or equal: *Z=1,N!=V*) |
> 其他助记符： 无条件执行 AL(always); 从不执行NV(never);


段寄存器：
|段寄存器|全拼|作用|
| --- | --- | --- |
| CS | Code Segment | 存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供。| 
| DS | Data Seg. | 指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。 | 
| SS | Stack Seg. | 指出当前堆栈的底部地址，即存放堆栈段的段基址。| 
| ES，FS，GS | Extra Seg. | 指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。|


## 基础知识：

常用的数据类型：
| 位数 | 类型 | 后缀 | 用例 | 
| --- | --- | --- | --- |
| 8 | byte 字节 | B | 数据 db |
| 16 | word 字 | 高位字节h,低位字节l | 数据 dw |
| 32 | dword 双字 | D | 数据dd |
| 64 | qword 四字 | Q | 数据dq |

ARM指令：
> ARM指令长度固定为32位；THUMB指令长度固定为16位。

ELF文件组成：
``` 
ELFFile {
    Hdr,
    Program Hdr,
    GNU Hash Table,
    Symbol Table,
    String Table
    RELA Relocation Table,
    JMPREL Relocation Table,
}

通常这部分在IDA中显示为cs:LOAD
```

``` cpp
typedef uint8_t     byte;
typedef uint16_t    half;
typedef int         offset;
typedef int32_t     word;
typedef int64_t     qword;

struct ElfHdr {
    byte    id[16];     //'\x7fELF‘
    half    type;       // 文件类型
    half    machine;    // 运行的体系结构
    word    version;    // 文件版本
    offset  entry;      // 入口点
    offset  phoff;      // Program Header 偏移字节
    offset  shoff;      // Section Header 偏移字节
    word    flags;      // 标志
    half    size;       // ELF头部大小
    half    phentsize;  // Program Header 每项大小
    half    phnum;      // Program Header 表项数
    half    shentsize;  // Section Header 每项大小
    half    shnum;      // Section Header 表项数
    half    shstrndx;   // 节名称的字符串索引
};


```

1、bss（可读可写）
     bss是英文Block Started by Symbol的简称，通常是指用来存放程序中未初始化的全局变量的一块内存区域，在程序载入时由内核清0。BSS段属于静态内存分配。它的初始值也是由用户自己定义的连接定位文件所确定，用户应该将它定义在可读写的RAM区内，源程序中使用malloc分配的内存就是这一块，它不是根据data大小确定，主要由程序中同时分配内存最大值所确定，不过如果超出了范围，也就是分配失败，可以等空间释放之后再分配。
2、text（只读）
    text段是程序代码段，在AT91库中是表示程序段的大小，它是由编译器在编译连接时自动计算的，当你在链接定位文件中将该符号放置在代码段后，那么该符号表示的值就是代码段大小，编译连接时，该符号所代表的值会自动代入到源程序中。
3、data（可读可写）
    data包含静态初始化的数据，所以有初值的全局变量和static变量在data区。段的起始位置也是由连接定位文件所确定，大小在编译连接时自动分配，它和你的程序大小没有关系，但和程序使用到的全局变量，常量数量相关。
1）stack/heap:
栈(stack)保存函数的局部变量和参数。是一种“后进先出”（Last In First Out，LIFO）的数据结构，这意味着最后放到栈上的数据，将会是第一个从栈上移走的数据。对于哪些暂时存贮的信息，和不需要长时间保存的信息来说，LIFO这种数据结构非常理想。在调用函数或过程后，系统通常会清除栈上保存的局部变量、函数调用信息及其它的信息。栈另外一个重要的特征是，它的地址空间“向下减少”，即当栈上保存的数据越多，栈的地址就越低。栈（stack）的顶部在可读写的RAM区的最后。
堆(heap)保存函数内部动态分配内存，是另外一种用来保存程序信息的数据结构，更准确的说是保存程序的动态变量。堆是“先进先出”（First In first Out，FIFO）数据结构。它只允许在堆的一端插入数据，在另一端移走数据。堆的地址空间“向上增加”，即当堆上保存的数据越多，堆的地址就越高。
一个程序的3个基本段：text段,data段,bss段。

text段在内存中被映射为只读，但.data和.bss是可写的。

text段:就是放程序代码的,编译时确定,只读；

data段:存放在编译阶段(而非运行时)就能确定的数据,可读可写。也就是通常所说的静态存储区,赋了初值的全局变量和赋初值的静态变量存放在这个区域,常量也存放在这个区域；

bss段:定义而没有赋初值的全局变量和静态变量,放在这个区域；

二、程序的内存分配
一个由C/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2、堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域(.data段)，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bss段)。 - 程序结束后有系统释放。

注：在采用段式内存管理的架构中（比如intel的80x86系统），.bss段（Block Started by Symbol segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中。
4、文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。

   ELF可以生成一种特殊的代码——与位置无关的代码(position-independent code,PIC)。用户对gcc使用-fPIC指示GNU编译系统生成PIC代码。它是实现共享库或共享可执行代码的基础．这种代码的特殊性在于它可以加载到内存地址空间的任何地址执行．这也是加载器可以很方便的在进程中动态链接共享库。
    PIC的实现运用了一个事实，就是代码段中任何指令和数据段中的任何变量之间的距离都是一个与代码段和数据段的绝对存储器位置无关的常量。因此，编译器在数据段开始的地方创建了一个表．叫做全局偏移量表(global offset table．GOT)。GOT包含每个被这个目标模块引用的全局数据目标的表目。编译器还为GOT中每个表目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个表目，使得它包含正确的绝对地址。PIC代码在代码中实现通过GOT间接的引用每个全局变量，这样，代码中本来简单的数据引用就变得复杂，必须加入得到GOT适当表目内容的指令。对只读数据的引用也根据同样的道理，所以，加上 IC编译成的代码比一般的代码开销大。

  如果一个elf可执行文件需要调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT(procedure linkage table，过程链接表)．这两个节之间的交互可以实现延迟绑定(lazy binging)，这种方法将过程地址的绑定推迟到第一次调用该函数。为了实现延迟绑定，GOT的头三条表目是特殊的：GOT[0]包含.dynamic段的地址，.dynamic段包含了动态链接器用来绑定过程地址的信息，比如符号的位置和重定位信息;GOT[1]包含动态链接器的标识;GOT[2]包含动态链接器的延迟绑定代码的入口点。GOT的其他表目为本模块要引用的一个全局变量或函数的地址。PLT是一个以16字节(32位平台中)表目的数组形式出现的代码序列。其中PLT[0]是一个特殊的表目，它跳转到动态链接器中执行;每个定义在共享库中并被本模块调用的函数在PLT中都有一个表目，从PLT[1]开始．模块对函数的调用会转到相应PLT表目中执行，这些表目由三条指令构成。第一条指令是跳转到相应的GOT存储的地址值中．第二条指令把函数相应的ID压入栈中，第三条指令跳转到PLT[O]中调用动态链接器解析函数地址，并把函数真正地址存入相应的GOT表目中。被调用函数GOT相应表目中存储的最初地址为相应PLT表目中第二条指令的地址值，函数第一次被调用后．GOT表目中的值就为函数的真正地址。因此，第一次调用函数时开销比较大．但是其后的每次调用都只会花费一条指令和一个间接的存储器引用。

## 常见汇编代码：

``` s
; 函数起止:
push ebp        ; 压栈
pop ebp         ; 出栈 

xor eax, eax    ; 数据清零


```