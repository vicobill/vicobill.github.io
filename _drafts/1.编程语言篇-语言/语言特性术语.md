鸭子类型：只要能响应此消息，那它就归于此类。

trait：可提供完整方法定义来定义行为，但不携带状态。

protocol/interface：通过方法签名定义多个行为。有时interface和trait互称。

mixin：不表示is-a-type-of关系的多重继承。用于添加行为到多个类。提供完整方法定义并可携带状态。

delegation：委托，指在另一原对象(发送者)环境下，对某对象(接收者)成员(属性或方法)求值。

```csharp
// 1. 组合方式
class A {
    void foo();
}
class B {
    delegate A a; // 构建委托连接
    void foo() {a.foo();}  // 委派给A进行处理。
}

// 2. 继承方式
class B : A {
    void foo() { base.foo();} // 委派给A
}

```

class: 用于创建对象、提供初始状态(成员变量)、实现行为(成员函数或方法)的可扩展代码模版

metaclass：创建类的类。

open/partial class: 可被修改的类（即使是内置类）。





约束主要有两种：

- 类型约束（基类型与子类型）
- 行为约束（方法签名）：子类型需要能响应指定消息。
  - 强消息约束：子类型必须实现方法
  - 弱消息约束：子类型可选实现。





变量
    - 值
    - 类型
        - primitive type 
        - compound type 
    - 内存分配
        - 堆
        - 栈
        - 寄存器
    - 生命周期
        - static 
        - local(temporary)
        - 自管理(heap)
    - 作用域
        - local
            - thread local 
            - file local 
            - block local 
            - class local
        - global
        - extern
    - 可变性
        - mutable
        - immutable
    - 


语句和表达式

引用、解引用、指针

参数 parameter， 形参 argument

延迟绑定/动态绑定

Closure： 
```julia
function f(x)
    g(y) = x+y 
    return g 
end
```

singleton：单例变量，是仅被引用一次的对象。

register： 变量缓存在寄存器中。

字段/数据成员/类属性/实例变量：成员变量。每个类实例都有其独立数据拷贝。

类变量/静态成员变量：只存在单个副本，而不管该类有多少个实例。

类函数/静态成员函数：

高阶函数：可以接收其他函数为参数的函数；可将函数当作结果返回。

sigil印记：是固定到一个符号变量名，可表示其数据类型或作用域。如：ruby中，$表示全局变量，@表示实例变量，@@表示类变量。

字串内嵌string interpolation：对字符串中占位符进行求值。通常由$,%,{}等作为占位符。

多态：为不同类型的实体提供单个接口或使用单个符号表示多种不同类型。
    - 特定多态：为任意一组单独制定的类型定义一个公共接口。例如函数重载。
    - 参数多态：一种或多种类型不是通过名称指定，而是通过可表示任何类型的抽象符号指定。例如：template<T>
    - 子类型： 例如继承
    - 鸭子类型。
    - 泛型。

访问器accessor:用于读取对象数据。
mutator： 用于修改对象数据。
manager： 用于初始化和销毁类的对象。如构造器和析构器。
    - finalizer: 与析构函数类似。但多用于具有垃圾回收机制的语言中。
抽象方法：只有签名，没有实现。常用于指定子类必须实现的方法。
类方法：在类上调用，而非在实例。
静态方法：与所有实例有关，而不是某个特定实例的方法。
操作符方法：定义或重定义符号的处理方式。
Covariant 协变返回类型：可在子类重载此方法时，可用"更窄"的类型替换原有类型。
contravariant 逆变：与协变相反，更窄到更宽。
dispatch table: 是 函数或方法指针列表。这是实现延迟绑定常见技巧。例如虚函数表。
multiple dispatch / multimethods多重派发：方法或函数可基于运行时类型动态派发
模版方法：定义了处理步骤的方法。其中的处理步骤，可由子类实现。
yield： 是在多线程中发生的动作，它迫使处理器放弃对当前正在运行线程的控制，并将其发送到具有相同调度优先级的正在运行的队列的尾部。
惰性初始化：只在需要时初始化。