# 术语

| 术语              | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| Project           | 包含组成独立游戏的所有内容和代码，与磁盘上的目录很相似。     |
| Level             | 创建的游戏场景。用户定义的游戏区域。是3D环境，放置了定义了整个玩家游玩的世界的一系列对象和几何体。Unreal中，每个关卡都分别存储在.umap文件。 |
| World             | 包含被加载的关卡列表。处理流式关卡和动态创建Actor。直接与World交互时不必要的，但它辅助提供游戏结构中的特殊引用点。 |
| Object            | 基本上Unreal中所有构件块都称为Object，包含许多功能，如垃圾回收，metadata，用于加载/保存的序列化等 |
| Actor             | 放置在世界中的对象，如光、网格、角色等。是Unreal引擎内部的程序类，定义3Dtransform数据的对象。也表示你可以任意可放置在关卡中的对象。是C++类，可用继承来自行扩展其功能。 |
| Viewport          | 观察世界的窗口。                                             |
| Editor Mode       | 不同模式描述关卡编辑器的主要行为，用以处理特定任务。         |
| Material          | 是可应用到网格，改变其可视外观的资源。                       |
| Blueprint         | 是处理特定任务的可视化脚本。带Blueprint的对象，类似于Unity中的Prefab |
| Map               | 保存了Level以及对象、光照信息和关卡特定设置的文件。          |
| Pawn              | 用来表示玩家或AI对象的Actor。表示可控制的游戏对象，典型的玩家的Avatar。Pawn由玩家或AI等自有的控制器控制移动。 |
| Character         | 用于表示带动画的生物Actor。比Pawn更多特化用以处理带骨骼的复杂游戏对象 |
| Component         | 用来给Actor添加片段功能。组件不可单独存在，必须加载Actor上。Actor将会访问并使用Component提供的功能。 |
| Controller        | 占有并控制Pawn。                                             |
| Player Controller | 从玩家的Gamepad、Touch、键鼠等获取的输入驱动玩家占有的Pawn或Character。每个游戏至少有一个PlayerController。PlayerController也是多人游戏的主要网络交互点。在多人游戏中，服务器有每个玩家的PlayerController实例，以允许调用每个玩家的网络功能。每个客户端只有一个关联于玩家的PlayerController以用于和服务器交互。 |
| Brush             | Brush是描述3D Volume以放置在关卡为了定义关卡几何体（BSP）和游戏Volume的Actor。典型的，你可以使用BSP画刷制造原型或游戏性测试。Volume有许多不同的效果，如Blocking Volume（不可见但阻止玩家通过），PainCausingVolume(当玩家进入圈时，施加伤害)或TriggerVolume（当玩家进出时触发事件）。 |
| GameMode          | 游戏模式表示游玩的游戏规则设置。这规则可包括：玩家如何加入游戏，能否暂停，关卡过渡，游戏特定行为如胜利条件等。可在Project Settings中设置默认游戏模式，但也可以每个关卡中重载。无论如何实现GameMode，每个关卡只有一个GameMode。对于多人游戏，GameMode只存在于服务器，规则被复制到每个连接的客户端。 |
| GameState         | 游戏状态包含需要复制到每个客户端的游戏信息。例如游戏分数，游戏是否已经开始，刷多少个AI等游戏特定的信息。多人游戏中，每个玩家机器上都有一个GameState实例，其中服务器的数据是最权威的。 |
| PlayerState       | 游戏参与者的状态，如人类玩家或模拟Player的机器人。非Player AI不会有PlayerState。例如包括玩家名称、分数、等级、HP、夺旗等。多人游戏中，所有玩家的PlayerState存在于所有机器上，可以从服务器复制数据到客户端以保持信息同步。 |
| GameInstance      | 在关卡切换时，需要保持的数据存储在GameInstance中。           |

UE4支持的格式：

| Asset Type | Supported Formats                               |
| ---------- | ----------------------------------------------- |
| 3D         | .fbx, .obj                                      |
| Texture    | .png, .jpeg, .bmp ,.tga, .dds, .exr, .psd, .hdr |
| Sound      | .wav                                            |
| Fonts      | .ttf, .otf                                      |
| Videos     | .mov, .mp4, .wmv                                |

在Unreal中，是通过自定义的C++或Blueprint的 Component来创建Actor的自定义行为（类似于Unity中脚本添加给GameObject）。

并非所有的都是Actor。Actor是UE4中能在Spawn到World的通用类。所以，所有能放置在Level中的是Actor。

Object是Unreal中所有类的基类。包含：Reflection和Serialization。

Actor Component是所有组件的基类，并继承于Object而非Actor。

在Unity可以使用基本GameObject和Component构建一切，Unreal可以通过Actor和Component构建一切。Unreal还提供额外层：Gameplay Framework.

在Unity中，你只可以编写Component扩展GameObject，在Unreal中，你可以编写Actor，而不仅仅只是编写Component。



实例化对象,Spawn Actor

* NewObject<>() 创建UObject类型对象。
* UWorld::SpawnActor() 创建AActor类型对象。

创建组件：CreateDefaultSubobject<>() 

获取组件：GetComponentByClass()

类型转换：Cast<>()

销毁Actor：Actor::Destroy();

延迟销毁对象：Actor::SetLifeSpan(); 设置预期生命期限

将Actor不可用：Actor::SetActorHiddenInGame(),Actor::SetActorEnableCollision(),Actor::SetActorTickEnabled();

从组件访问Actor：Component::GetOwner();

从Actor访问组件：Actor::FindComponentByClass<>()

查找Actor：

* 通过名称查找对象：FindObject< Actor >() 
* TActorIterator< Actor > it(GetWorld())， 通过World查找对象。
  * Actor::ActorHasTag() 获取Actor的标签
* TObjectItrator< UObject >() 查找Object对象

给Actor设置标签：Actor.Tags.AddUnique()

给Component添加标签：Component.ComponentTags.AddUnique()；比较标签：Component.CompareTag();



Unreal中，任何PrimitiveComponent都可以是物理化对象。通用Primitive Component是ShapeComponent(Capsule,Sphere,Box),StaticMeshComponent,SkeletalMeshComponent。不像Unity分离Collision和可视化分为独立组件，Unreal将可能的物理化和可视化放在PrimitiveComponent。任意Component都可以在世界中有一个几何体，可渲染或与其他PrimitiveCompoenn子类的物理式交互。对于物理组，UE4使用Collision Channel，Unity使用Layer。



Trigger：

* Actor::NotifyActorBeginOverlap() 响应trigger enter事件
* Actor::NotifyActorEndOverlap()响应trigger exit事件



输入事件：

* InputComponent::BindAction();InputComponent::BindAxis();



Unity中的单位是1米，Unreal中的是1厘米。Unreal4遵循左手坐标系，X向前，Y向右，Z向上。

check()严重错误。ensure()报告错误。



# 常用组件

## Physics

* DestructibleComponent： 可破坏组件
* PhysicsConstraintComponent: 允许将两个刚体连结在一起
* PhysicsHandleComponent:可以抓取并移动
* PhysicsThrusterComponent: 物理推进组件，可以将物体向上持续推进
* RasialForceComponent:星形力组件，可以模拟爆炸的力，这个力通常是一次性的。

## Audio

* AudioComponent:允许添加Sound Wave或Sound Cue,提供音频源

## Camera:

* CameraComponent: 添加相机行为
* SpringArmComponent：相机支架组件，可模拟相机跟随

## Light

* DirectionalLightComponent: 模拟定向光
* Point Light Component： 点光
* SkyLightComponent：捕获关卡遥远距离部分，并以光源形式应用到场景
* SpotLightComponent：聚光灯
* RectLightComponent: 矩形光，如电视荧光、广告屏光等

# 材质

材质是改变对象和关卡最关键的部分。Unreal中，材质是通过HLSL代码实现，以可视化脚本形式表现。材质由

* 颜色（float[4])
* 纹理：组织像素数据的简单图片。这些图片可描述物体的颜色、光耀、透明度以及其他部分。一个材质，可能使用多个纹理并对其全部采样并应用，以用于不同目的。例如，材质可能由Base Color纹理,Specular纹理，NormalMap，附加的，也可Emissive和Roughness数据。

有不同的材质类型：

* Surface： 用于物体的表面
* Deferred Decal:贴花
* Light Function：光照
* PostProcess: 后期处理



大气雾：整个世界的大气光照效果。这可让室外场景更加真实。

指数级高度雾：用于模拟局部雾效果。

Light Shaft：光线可由径向光模拟真实世界的模糊光射线或大气阴影。



# 网络与多人

网络模式：

* Standalone:独立模式，不接收远端连接。适合单人或本地多人游戏
* DedicatedServer:专有服务器。无本地玩家，抛弃sound,graphic,user input,其他面向玩家的特性，可以运行得更快。用于多人游戏的可信主机，如MOBA，MMO，在线射击，需要可信服务器。
* ListenServer：包含本地玩家的主机，也允许远程玩家连接。适合多人游戏，无需专有服务器。
* Client：客户端，无任何服务器逻辑。

服务器处理重要决定，如授权状态，处理客户端连接，旅行至新地图，处理游戏流程：开始，结束等。

启动命令行：

| 类型             | 命令                                             |
| ---------------- | ------------------------------------------------ |
| Listen Server    | UE4Editor ProjectName MapName?Listen -game       |
| Dedicated Server | UE4Editor ProjectName MapName -server -game -log |
| Client           | UE4Editor ProjectName ServerIP -game             |

网络连接主要步骤：

1. 客户端发送连接请求
2. 如果服务器接受，将会返回当前地图
3. 服务器等待客户端加载此地图
4. 当加载完成，服务器调用AGameModeBase::PreLogin()
   1. 这允许GameMode拒绝连接
5. 如果接受，服务器将调用AGameModeBase::Login()
   1. 这会创建PlayerController，并复制到新的连接的客户端。一旦接收到，PlayerController将替代客户端的临时PlayerController
   2. APlayerController::BeginPlay()将会调用。需要注意现在调用Actor的RPC是不安全的。你需要等到AGameModeBase::PostLogin()调用
6. 如果一切正常，AGameModeBase::PostLogin() 将会被调用
   1. 此时，服务器调用PlayerController的RPC函数会是安全的。



无缝和非无缝旅行：无缝是非阻塞式操作，非无缝则不是。当执行非无缝旅行时，客户端会断开并再次连上服务器以载入新地图。UE4鼓励使用无缝式旅行。有3个函数驱动旅行：

* UEngine::Browse()
  * 加载新地图时类似于硬性重置
  * 始终以非无缝旅行结果
  * 旅行前断开当前客户端
  * 专有服务器不可旅行至其他服务器，所以地图必须是本地的，不可是url
* UWorld::ServerTravel()
  * 只用于服务器
  * 将服务器跳至新世界/关卡
  * 所有连接的客户端都会追随
  * 是多人游戏中地图间旅行，由服务器调用此函数
  * 这会调用所有连接的客户端玩家的APlayerController::ClientTravel
* APlayerController::ClientTravel()
  * 如果从客户端调用，旅行至新服务器
  * 如果从服务器调用，旅行至新地图（保持当前服务器连接）

要允许无缝旅行，需要设置过渡地图。通过UGameMapsSettings::TrasitionMap 属性。此属性默认是空的。一旦设置了过渡地图，设置AGameModeBase::bUseSeamlessTravel为true。

无缝旅行流程：

1. 标记将在过渡地图persist的actor
2. 旅行至过渡地图
3. 标记将在final关卡persist的actor
4. 旅行至final 关卡

当使用无缝旅行时，可将Actor带至新地图。默认情况下，这些actor将自动persist：

* GameMode (Server Only)
  * AGameModeBase::GetSeamlessTravelActorList() 添加任意Actor
* 有可用的PlayerState的所有Controller(Server Only)
* 所有PlayerController（server only)
* 所有本地PlayerController(server & client)
  * 调用本地PlayerController的APlayerController::GetSeamlessTravelActorList()添加任意Actor

# Gameplay Framework

游戏性框架，包含了许多基本游戏功能模块。

Game由GameMode和GameState组成。PlayerController和AIController占有Character或Pawn。PlayerController包含HUD，Input，PlayerCameraManager。

游戏流程：

1. StartEngine：引擎开始
2. UGameEngine::Init()：引擎初始化
3. 创建UGameInstance：创建游戏实例
4. UGameInstance::InitializeStandalone()
5. UGameInstance::Init()：游戏实例初始化
6. 创建UOnlineSession并注册delegates：注册回调函数
7. UEngine::Start()：
8. UWorld::BeginPlay()：开始游戏，初始化World
9. AGameMode::StartPlay()：初始化GameMode
10. AGameMode::StartMatch()：开始匹配
11. SpawnActors并开始游戏：刷出玩家并真正开始游戏。

AGameModeBase包含的主要函数/事件：

| 函数/事件                   | 用途                                                         |
| --------------------------- | ------------------------------------------------------------ |
| InitGame                    | 这在所有Actor运行PreInitializeComponents()之前，包括GameMode 实例自身 |
| PreLogin                    | 接受或拒绝连接请求                                           |
| PostLogin                   | 在成功登录后调用。现在可安全调用RPC并可实现PlayerController.OnPostLogin以添加额外逻辑 |
| HandleStartingNewPlayer     | 在PostLogin或无缝切换后调用。可在blueprint中重载以实现对新玩家的操作。默认为玩家创建Pawn |
| RestartPlayer               | 在开始刷出Pawn时调用。也有RestartPlayerAtPlayerStart()和RestartPlayerAtTransform()以指示Pawn的刷出位置。OnRestartPlayer()可在BP中添加此函数调用完成后的操作 |
| SpawnDefaultPawnAtTransform | 实际刷出玩家。可在BP中重载                                   |
| Logout                      | 当玩家离开或被销毁。可在BP实现OnLogout以添加处理。           |

每个GameModeActor会在关卡通过UGameEngine::LoadMap()载入时初始化。GameMode只存在于服务器，如果玩家需要此GameMode的更新信息，这些信息保存并同步在GameState中。

AGameMode包含一个有关比赛的状态机：

* EnteringMap: 是初始状态。Actor尚未ticking，世界尚未初始化。当一切加载后，将会进入下一状态。
* WaitingToStart：当进入此状态时，HandleMatchIsWaitingToStart被调用。Actors开始ticking,但玩家尚未spawn.如果ReadyToStartMatch返回true或调用StartMatch()后，将会进入下一状态。
* InProgress：当进入此状态时，HandleMatchHasStarted被调用。接着会调用所有Actor的BeginPlay()。此时，游戏正常开始。当ReadyToEndMatch或调用EndMatch(),将会进入下一状态。
* WaitingPostMatch:是倒数第二个状态，进入此状态时，会调用HandleMatchHadEnded.Actor仍在ticking,但新玩家不可再加入。当地图开始转移时，进入下一状态。
* LeavingMap:是最后的状态。会调用HandleLeavingMap。当转移到新地图，比赛会停在当前状态，并会转到EnteringMap状态。
* Aborted是失败状态，可在调用AbortMatch()时进入此状态。



Spectator 是DefaultPawn的子类。



# UI

UI分为两部分：HUD和UI。HUD通常用于显示信息，界面元素不可交互。UI的元素可交互，它们可以作为世界的一部分存在。

Canvas是用于绘制UI对象。

Slate是自定义的UI框架。



## 蓝图Timeline

Timeline是一段曲线，曲线轴内的数值是可使用，以修改属性。曲线变量包括：float，Vector3，Color,Event 几种。时间轴单位为秒。

**时间轴节点（Timeline Nodes）** 是蓝图中的特殊节点，它们允许根据游戏中的事件快速设计和播放基于时间的简单动画。时间轴与简单Matinee序列有几分类似， 因为它们允许对简单值进行动画处理，并允许随着时间的推移触发事件。您可以通过在图表（Graph）选项卡中 或我的蓝图（My Blueprint）选项卡中双击时间轴（Timeline），在蓝图编辑器中直接编辑这些时间轴。它们经过专门设计，用于处理简单的非电影任务，例如开门、改变光源 或在场景中对Actor执行其他以时间为中心的操作。