---
title: 游戏引擎-研究报告
layout: post
---
# 游戏引擎研究报告

@refer:Torque3,TombstoneEngine,CryEngine,Unreal4,Unity,Lumberyard,Source2,Panda3D,Leadwerks,Xenko,id Tech 4,Blender Game Engine,Love2D

## 编程语言

现今的3D游戏引擎通常使用OOP编程语言，特别是无垃圾回收的静态编程语言，因为游戏引擎需要的高性能（C++）。附以带垃圾回收、动态、简单上手、易扩展的脚本语言作为逻辑编写语言（如Lua，mruby，python等）。

### 惯用编码技巧

- 函数名：函数是最基本的入口。一切操作皆是函数。
  - 非虚成员函数：1. 操作成员变量。2. 辅助函数，通常是私有函数。
  - 虚成员函数：用于实现多态，通常用在消息响应中（通常非手动调用）。
  - 静态成员函数：通常是通用功能函数，在外部调用。

- 接口：接口通常预先约定的一系列操作，以供之后实现。通常通过配置或手动编写代码进行实例化。

  - 模块，插件。通常游戏引擎最为核心的是图形，但为了扩展到其他渲染API，通常需要对功能进行扩展或再次实现。模块和插件形式可以扩展已有的功能或替换已有的功能。

    对于模块或插件而言，通常只需要有对应的接口函数即可，由引擎自行实例化以及加载。这样可以动态加载或卸载模块功能，而无需更改引擎已有代码。

  - 组件：组件可以附加到某一实体上，给实体提供相应功能。这样可以便捷地如同堆积木的方式构建实体。

  - Mix-in类。抽象类。扩展功能的另一种方式。

- 事件/消息系统：整个OOP编程语言中最核心的系统，也是游戏开发中最普遍的系统。用于解耦模块，使模块可以灵活扩展。通常以观察者模式实现。

  - delegate。委托。将功能的处理，委托给另外的一个对象。即事件要进行处理时，交给对应的实例进行处理。通常委托用于定义对应业务的委托类型，委托类型可以有多个委托实例进行处理。通常流程：创建一个委托类型，添加委托实例，委托接收事件，并将事件分发给委托实例，由委托实例进行处理。delegate通常对应于语言中的函数指针。delegate通常持有某个函数的指针，在事件发生时，调用对应的函数进行处理。delegate的委托实例可以动态增减，以更灵活的方式处理事件。

- 泛型：通常在容器、通用算法中应用广泛。泛型是在编译期进行指定类型，会带来编译时间的增加，因此需要合理使用泛型。

  - 静态多态绑定。与接口形式相比，泛型多态无需继承这一手段，提高了运行时性能，减少继承层次，减少类型转换带来的消耗。

- 头文件只有声明，CPP文件里是实现。如果头文件有实现，通常使用inline方式进行内联，以优化方法调用时间。

  - 开闭原则。通常实现代码和声明代码放在一起，如果不使用IDE代码折叠，代码量会非常多，难以阅读理解。头文件只有声明，通过方法和数据，可以快速定位类的使用范围。

- 节点系： 节点是游戏中使用比较多的一种手段。

## 功能模块

* 图形：图形渲染是游戏引擎中最重要的部分。一款游戏引擎的图形部分从效果、性能上评选，直接决定游戏引擎的品级。
  * Shader
* 音频：音频播放是游戏体验中最基本的元素。音乐与音效的播放处理，营造更为真实的3D剧情场景，使玩家有沉浸感。以及，玩家语音交流。
* 输入：输入是玩家与游戏交互的最基本功能。
* UI或HUD：界面交互通常是建立在图形和输入基础之上。
* 物理：最基本的物理效果是碰撞检测。让游戏世界更加真实，符合真实物理规律。应用最多的，也最基本的是碰撞检测。在物理系统中，也有光线追踪，应用于渲染技术中。
* 动画：动画系统在游戏中用于管理角色移动等，通常独立出来。动画模块通常使用序列帧形式，但也有骨骼动画、面部表情等
* 影片：在游戏中，很多时候需要播放过场动画，可通过加载外部视频，或内置影片等形式。在交互式电影游戏中，通常采用内置影片形式减少资源量，提高沉浸感。
* 粒子系统：用于游戏中多样、炫酷的特效必需。
* 场景管理：场景管理通常使用BSP、四叉树等管理，可高效管理大型地图。
* 关卡管理：管理关卡内物体的渲染。
  * 地形
  * 植被
  * 天气
  * 雾
  * 天空
  * 云
* 网络：多人游戏中必须的功能。网络系统用于玩家与玩家之间的对战与交互，增添游戏的乐趣。网络系统中， 玩家屏幕之间需要进行同步，与作弊检测。
* AI：在单人游戏中，NPC的智能程度直接决定游戏的有趣性、挑战性。
* 脚本系统：脚本比C++能更快速开发游戏原型及迭代开发。
* 系统化功能：
  * 资源管理：资源载入与卸载（图片、字体、音频、视频、国际化字符等）；资源包管理；无缝世界加载；游戏关卡管理（序列化与反序列化）等。
  * Entity系统：用于管理游戏世界内对象。
  * 模块/插件管理：对于游戏引擎而言，需要与时俱进，通常现有模块只关注现在的解决方案，模块管理可以扩展现有功能。
  * Flowgraph系统：针对无编程经验者而言，可视化流程图很有吸引力。
  * 控制台系统：用于在游戏中实现特殊目的，通过敲击命令方式，弥补UI系统功能不足的问题。
  * Profiler，Logger，Debugger，Auto Test等：用于分析开发过程中的瓶颈与潜在问题。
* 其他杂项：
  * Launcher： 跨平台游戏启动器，可以选择不同游戏模组开始游戏
  * 跨平台的抽象系统层代码库：
  * 通用程序开发代码库：容器，数学，内存，线程，时间

## 游戏开发扩展

* Steamwork集成
* 用户行为分析
* 广告
* 与Git等版本管理器集成
* Replay 回放与直播
* 支付与购买API

## 游戏引擎编辑器	

* 关卡编辑器
* 模型编辑器：顶点编辑，面编辑，雕刻等
* 地形编辑器：地形，植被，水体，风，天空，道路等
* 影片编辑器：制作内置摄像机序列，可导出为视频。
* 动画编辑器：编辑人物骨骼动画、面部表情等
* 纹理与材质编辑器：编辑模型对应的纹理与材质，可达到不同的效果。
* UI编辑器：对UI进行布局，以及UI交互事件
* 粒子编辑器：粒子特效制作
* AI编辑器：导航（寻路）、决策树、行为树、可视区域编辑等
* 音频混合器：混合音频，达到多种音乐效果
* 物理模拟编辑器：编辑物体的物理效果，如绳子、布料、发丝、刚体等。





# 内容制作流程

## Pre-Demo

* 确定游戏的核心功能、画面表现（2D或3D）。

  此阶段，无需过于纠结游戏的世界观、价值观等等，可以有，但不用太过细化，对于这些内容的确定，只需要粗略大概即可，起纲领作用。

  画面表现这是需要考虑的，画面表现直接决定所使用的引擎工具。对于通用引擎（3D/2D通吃）而言，则画面表现也无需太过在意。但对于没有通用引擎的游戏制作组来说，画面则需要首先考虑。

* 确定游戏开发所使用的引擎工具。

  通常而言，引擎会决定整个资源制作和开发工具链，甚至影响开发模式。选用的引擎，最好能支持Prototype版本快速开发所需的资源或流程。


## Demo/Prototype/Pre-Alpha

* 核心功能创建。Demo/Prototype版本制作。

  在此版本制作过程中，主要是核心功能代码奠定。

  * 模型：可使用体元模型（立体、球、胶囊体）或已有的模型作为演示用。

    在3D引擎中，通常使用BSP画刷构建最原始的关卡布局。BSP画刷能创建常见的基本几何体，通过BSP编辑工具，可快速创建关卡中物体对象的原型。

    * BSP画刷的用途：
      * 设计出关卡草图以及关卡路径
      * 运行关卡测试流程和游戏性
      * 修改布局并反复测试
      * 起始的网格物体环节
      * 起始的光照环节
      * 对碰撞即性能问题的游戏测试
      * 润色。

    画刷分为构建型、添加型、挖空型、非固体等4中画刷类别。

  * UI界面：可以非常简单，不用过分修饰和摆放，基本能用即可。

  * 动作：可以没有或使用已有的动作资源，不必刻意调整。

  * 数据：不必精准修饰，能表达基本的意思即可。

  * 音频：可以没有

  * 特效：可以没有或沿用以前的特效。

  * 剧情：剧情通常有作家或编剧等类似的人来处理，在Demo阶段，不必有。

* 细化核心，添加辅助。主要用于演示和宣传。

  此阶段对demo进行打磨，根据核心功能，细化核心功能，并引入其他辅助核心的功能。

  并可以以此原型制作出对应的宣传CG。

## Alpha

* 对游戏中的内容进行调优。
  * 模型：对应当前现有的关卡、道具等，需要有对应、合适、具有表现张力的模型。
  * 动作：对应当前现有关卡、道具、敌人等，需要有对应、合适、具有表现张力的动作。对于主要角色、道具等，该有的动作不可少。对于次要角色、道具，需要具备主要的几个动作。
  * UI界面：需要经过UX设计，合理布局。UI的动画效果和音效，都需要具备齐全。
  * 数据：数据可以进行调优测试，进行正式的第一次平衡性调整。
  * 音频：对于现有关卡、道具、敌人等，背景音乐、音效、人物角色配音等，如果不可缺少，那必定要存在。
  * 特效：对于现有关卡、道具、敌人、剧情等，主要特效不可缺少，但无需太过于精确、炫酷。对于屏幕后期处理特效不可缺少，对于技能特效，可以不必太多精细。
  * 剧情：主线剧情，需要完备。支线剧情或其他DLC等剧情，可以先不加入到当前版本中。可以作为后期系列进行丰富。主线剧情，一定要引人入胜，身临其境。
  * 宣传CG：宣传CG应该制作完毕，作为先投放到市场，CG质量可以决定玩家的热情和兴趣。



## Beta

* 对测试玩家反馈的内容，进行甄选，以此修改现有功能。

  * UI界面：UI界面是与玩家打交道的主要部分，因此测试玩家的反馈通常包含UI的内容。
  * 特效：特效也是与玩家长打交道的部分。
  * 剧情：剧情虽然通常并不受玩家反馈意见而左右，但通常多听听玩家的意见，集思广益也不错。

* 优化。

  对游戏的最终性能进行优化。对于重大BUG进行消除。对于隐藏BUG做好反馈处理。

* 对于DLC、周边、论坛、DVD发行版、销售、客服、推广、等等，需要开始动工。

  Beta版不是大量改进的版本，因此`甄选`二字非常重要。如果沉迷于玩家的反馈无法自拔，那么距离游戏的发布永远都是遥遥无期。

  在改进后，即可在优化后，投放市场。



## Release

* 投放市场，主要对应于以下几个方面：
  * 销售：为了提高销售，通常有很多种手段：
    * 周边产品：如玩偶、小说、电影、音乐、画集、引擎授权、文化衫、实物店等等
    * 游戏本体DVD/U盘：在游戏发布后，玩家购买后发送的主要载体。
    * DLC：游戏扩展内容包。
    * 游戏内奖励：通常即游戏内商店。
    * 线下活动奖励：例如，组织比赛等等。
  * 客服：为了更好地获取玩家的反馈，需要良好的服务质量。
    * 论坛：论坛作为玩家主要聚集地，可为玩家提供攻略、吐槽等等方式
    * 电话：有时，文字说话未必能立即将自己的情绪、文字组织清楚，电话方式更为直接，也更能反应玩家对于某个问题的情绪。
    * 邮件：邮件作为方便的手段，更为正式，让玩家觉得自己的建议受到了重视。
    * 游戏内反馈：快捷方便的反馈手段，也是必需的。
  * 推广：为了扩大销量，推广也是不容忽视的
    * 宣传片：宣传片能很好地对游戏产品做出扬长避短的作用。
    * 广告：广告能提升受众，提高潜在玩家数量。
    * 玩家间自分享：自分享是最具说服力的，也是宣传最为扎实的，是核心用户主要来源地。
    * 主播直播：类似于玩家间自分享，通常主播带来的用户量比自分享用户量要庞大。
    * 电影：类似活动的一种，电影的面世，可以扩大潜在玩家数量，这些数量通常带来高质量的玩家。
    * 小说：类似电影。但通常受众是死忠fans。
    * 组织活动：例如比赛、同城会等等，可以让玩家之间自行扩散。
    * 跨企合作：利用其他行业企业之间的资源共享，提高玩家受众群，互利共赢。
  * 扩展开发：对于后期新DLC、系列作品等的开发， 需要对代码进行整理，提升代码质量，提高现有代码性能，编写并优化制作工具，提升开发效率。
    * 配套工具开发。在进行下一次游戏开发之前，将所需要用到的配套工具开发齐全，以加速开发流程。
    * 代码重构。以易于下一次游戏开发，代码重复利用率。





# 图形学

计算机图形学，主要研究的是如何在计算机中表现出最终图像。计算机中抽象的数据没有直观的图形更易让人接受。一幅图片中蕴含的信息量是巨大的。

计算机产生图形的方式有以下几种：

* 一帧一帧绘制：期间要用户等待
* 用户控制下的一帧一帧绘制：一系列的帧可被连续绘制，当用户控制后，绘制下一系列帧。（如PowerPoint）
* 动画：一系列的帧按一定速率处理，用户很乐意观看（如影片）
* 交互式程序： 观看交互式的图形表达时，用户利用输入设备控制帧的流向，且流向是任意的，在写程序时是无法预知的。（例如游戏）

主要应用：

* 艺术、娱乐和出版行业
* 感知和图像处理
* 过程监视。监控。
* 仿真显示。
* 计算机辅助设计
* 科学分析与体可视化。



计算机图形学中制作图像的基本元素：（图元）

* 点(Dot):

* 线(Line):

* 折线（Polyline)：由一系列直线段相互连接而成。一条折线可以看起来像平滑的曲线。由折线组成的图，有时称为线条绘画（素描）。最简单的折线是一条单独的直线段。在OpenGL中，折线通常由顶点列表定义（Vertex List）。

  折线的重要属性包括边的颜色和粗细、虚线的方式、粗变在端点混合的方式等。

* 文本：

  图形设备有两种不同的显示模式：图形模式和文本模式。文本模式用于字符的简单输入输出，用来控制操作系统或编写代码。这种方式显示的文本采用嵌入式的字符发生器。一般来说这些字符不能在显示器上任意放置，只能放置在规则网格的某一行和列上。

  图形模式提供更丰富的字符形状，字符能够被随意放置。

  文本有许多属性，最重要的是：字体、色彩、大小、间距和倾斜度。

  * 字体：是一类具有特殊风格和大小的字符形状集。每个字符的形状能够用折线（或更复杂的曲线）表示或点阵表示。
  * 倾斜度：常用来注释图形中的某一部分。

* 填充区域：指填充时的颜色和图案。其边界通常是多边形。

* 光栅图像：它由许多非常小的不同灰度的单元组成。每个单元被称为像素。像素混合在一起组成一幅图像。

  光栅图像以数值数组的形式存储在计算机中。这个数据可看成是矩形的，由某些行和列组成，每个数值代表存储的像素值。这个数组整体被称为一个像素图或位图。

  光栅图像制作来源：

  * 手工设计图像。借助绘图软件，决定每个单元所需的值，并将结果保存到文件。
  * 计算机生成图像。用算法绘制在计算机内存中抽象建模的场景。
  * 扫描图片。照片或视频图像可以被数字化。将网格放置在原始图像上，在每个网格点上设备读取匹配的最相近的颜色，然后将获得的位图保存在文件以备用。

  光栅图像的一个重要方面是位图的色彩或灰度的表现方式。

  * 灰度光栅图像。只有两个值：0,1。使用8比特即1字节存储像素值。
    * 像素深度的影响：灰度量化。有时一个原本使用每像素8个比特的图像会改变为每像素使用更少的比特数，如果显示设备不能显示很高的灰度级别或整个图片占据太多存储空间，此时原图的灰色渐变，会变成一系列固定值的灰度色块：条带化。
  * 彩色光栅图像。彩色图像中，每个像素都有一个颜色值，即一组可以代表颜色数值。有一些方式可将数值与色彩联系起来，如RGB混合。

  显示设备：

  * 光栅显示器：有一个显示屏幕，以用于显示图像。屏幕可表达为若干行列，并与像素联系起来。显示器内置坐标系将图像给定像素与屏幕上的物理位置联系起来。通常原点在左上角。

    光栅显示器总是与帧缓冲联系在一起。帧缓冲区是存储器中一块足够容纳要显示图片的区域。可以是显示器自带的物理存储或主机存储。

    从帧缓冲到屏幕，由扫描控制器负责处理。它自动运行，一像素一像素地重复同样的工作。它引发帧缓冲区通过转换器将每个像素输送至显示屏面合适的物理位置。转换器接收像素值，将其转换成色彩值，并在显示器上生成一个彩色点。

    在整个帧缓冲区中扫描图像，每像素值只被扫描一次，它在屏幕上的对应点显示正确的强度或颜色。某些设备中，这种扫描必需每秒钟重复许多次，用来保持和刷新显示器上的图像。

    视频显示器的功能基于CRT。每像素RGB分别使用一对比特值，输入到三个数模转换器（DAC）中，将逻辑值转换成真实电压值。三个电压值分别对应CRT三个电子枪，轮流发射三条电子光束，其亮度正比于电压值。偏转线圈作用于三个光束使它们能在阴极射线管正确位置刺激3个荧光点。这些点紧挨在一起，人眼把它们堪称1个合成点，得到三原色混色值。荧光点的发光会迅速消失，所以CRT图像必需频繁地刷新（60次/秒）以防止闪烁。在每个刷新间隔，扫描控制器迅速扫描整个帧缓冲存储器，把每个像素值传送到显示屏表面的正确位置。

  * 视频卡/3D加速器。

    随着图形越来越复杂，海量数据的图像需要迅速传给显示器，由于CPU和显示器这两种设备不在同一位置，数据需要通过总线传输，但在传输前，需要完成一系列复杂的、基于当前总线活动时间检测和数据检测。另一重要发展是图形卡。它们有着特别设计的线路，能快速响应，从而满足数据从CPu到显示器的实时传输需要。

    无论何时图像成形，定义场景的集合数据必须经过大量的处理步骤，才能最终输出到屏幕中。这些步骤通常称为图形管线。

    可编程图形卡：允许开发者通过编辑管线中加载数据的算法，来指定GPU工作。

## OpenGL：设备无关的API

###　窗口

现在图形系统是基于窗口的，并且管理多个重叠窗口的显示。用户可以用鼠标在屏幕上移动窗口，也可以调整窗口大小。

#### 事件驱动编程

系统自动管理事件队列，该事件队列接收已经发生的特定事件信息，并按照先来先服务的顺序处理这些信息。程序员将程序组织成`回调函数`的集合，这些回调函数一有事件发生就执行。当回调函数执行完后，应用程序从队列移走相应的消息，再从调用出恢复成等待状态。

程序员需要编写回调函数内部事件产生时的处理，不需编写调用回调函数的指令，调用回调函数是由系统自动处理的。

事件驱动编程中，一定有将事件与回调函数关联起来的方法，这个方法称为`注册回调函数`。每个事件类型，都必需用回调函数注册。

### 状态

OpenGL是由许多状态变量组成的状态机，这些状态包括点的大小、绘图的颜色、屏幕窗口大小等。在给定新值前，状态变量的值一直保持不变。	因此在每次绘图形之前，都需要了解当前的绘制状态如何。

### OPENGL基本图元

基本的图元：OpenGL使用顶点描述方式决定图形。

* 点(Point)：点以分散形式绘制。
* 线(Line)：成对读取顶点，并在每对之间画一条单独的线。是开放式图形。
  * 折线带（Line Strip):是有序点列表。
  * 折线环（Line Loop）:将最后一点与第一点相连，形成多边形
* 多边形填充（POLYGON）：绘制的图形与线环不同，Polygon会填充颜色或图案。是闭合式图形。
* 矩形填充区域（Rect）：矩形是比较特殊的多边形。
* 三角形（Triangle）：一次使用3个顶点，每次绘制一个独立的三角形。
  * 三角形带（Triangle Strip）：基于3个一组的顶点v0,v1,v2，然后是v1,v2,v3，然后是v2,v3,v4以此类推，绘制一系列三角形。（按同样的顺序即逆时针方向遍历所有的三角形。）
  * 三角形扇（Triangle Fan）：基于3个一组的顶点v0,v1,v2，然后是v0,v2,v3，接着是v0,v3,v2，以此类推，绘制一系列与v0相连的三角形。
* 方片（Quad）：一次使用4个顶点，每次绘制一个独立的四边形。
  * 方片带（Quad Strip）：基于4个一组的顶点v0,v1,v3,v2,然后是v1,v3,v5,v4，接着是v4,v5,v7,v6，以此类推，绘制一系列四边形（按同样的顺序遍历所有四边形）。

### 坐标系

主要存在的坐标系：

* 世界坐标系：场景中的物体在实际世界中的坐标。
* 摄像机坐标系：用于裁剪物体，减少绘制量。不在摄像机内的物体，不用显示。
* Viewport坐标系：与屏幕窗口对齐的矩形，作为与屏幕坐标无关的坐标系。在图形最终显示到屏幕上之前，可能有各种变换，通过viewport这样图形在变换时，无需刻意了解屏幕坐标系的构成。viewport会自动映射到屏幕坐标系中。OpenGL Viewport以左下角为原点。
* 屏幕坐标系：通常而言，从左上角作为原点。viewport坐标系可以很容易转换成屏幕坐标系。

### 双缓冲

双缓冲用一些内存空间模拟额外的屏幕，这个屏幕并不真实存在，并且所有的绘制都在这个缓冲区中进行。这样在交替显示图形时，会更流畅。



























# 常用UI元素

| 元素         | 作用                                                 |
| ------------ | ---------------------------------------------------- |
| Button       | 可供用户选择，按下                                   |
| CheckBox     | 开关选择                                             |
| Radio Button | 单选                                                 |
| Static Text  | 显示一串短文字，帮助用户管理程序                     |
| Edit Box     | 可编辑文本区                                         |
| Spin         | 微调控制项。数值快速地增加或减少                     |
| Panel        | 一组接口原件。能重新设置大小。                       |
| List View    | 列表视图                                             |
| Seperator    | 隔离器。可视化助手，能帮助管理屏幕上许多选项和元件。 |
| Scroll View  | 可滚动视图                                           |
| Dropdown     | 下拉框                                               |















# 游戏框架

## 实体与组件

* 实体是包含组件的容器，实体所具有的功能的实现由组件来完成。

* 蓝图/预制件：是预先制作好的、由许多组件组成的实体（类）。蓝图实例可以单独修改，也可以通过修改蓝图，一起修改所有蓝图实例。
  * 蓝图的宏：类似于通用函数。类似于类函数（静态函数）。
  * 蓝图的接口：是接口函数的集合。类似于接口类。

## 常用实体（Actor）：

| 游戏性                    | 作用                                                         |
| ------------------------- | ------------------------------------------------------------ |
| 触发器（Trigger）         | 当关卡中的其他对象同其交互时触发事件。 换句话说，它们被用于 *触发* 事件从而响应关卡中的其它操作。 触发器一般都是相同的，不同之处仅是其影响区域的形状 - 盒体、胶囊体及球体 - 触发器使用这些影响区域来检测另一个对象是否激活了它。 |
| 目标点（TargetPoint）     | 为游戏创建世界场景时，有时需要在其中放置和生成各种物体，以便玩家与它们进行互动。**目标点 Actor** 的作用正在于此，在世界场景中设定一个一般点，作为物体生成的点 |
| 玩家出生点（PlayerStart） | 放置在关卡中，用于指定游戏开始时玩家起始位置的Actor。        |
| Matiniee                  | 可以通过 **Matinee** 动画工具使得Actor的属性随着时间产生动画，从而创建动态的游戏性或者游戏中的过场动画。该系统是基于专用的动画轨迹的，您可以在该轨迹上放置关键帧来设置关卡中actor的某些属性的值。Matinee动画编辑器和用于视频编辑的非线性编辑器类似，这使得它对于那些视频制作专业人员来说很熟悉。 |

| 网格&几何体  | 作用                                                         |
| ------------ | ------------------------------------------------------------ |
| 静态网格模型 | 用于在场景中显示一个网格物体。尽管其名称暗示该Actor是静态的或者是不能移动的，但是此名称中的 *静态* 是指这种网格物体类型使用的是StaticMesh（静态网格物体）。由于这些网格物体的几何体不能改变，所以这些网格物体是静态的。但是，实际上在游戏运行过程中可以通过其他方式来移动及修改Actor。这些Actor一般用作为 *世界几何体* 及装饰性网格物体，以创建关卡的场景 |
| 画刷Brush    | 用于在场景中显示简单的三维几何体。在关卡编辑器中，可以使用‘几何体编辑’模式修改这些Actor。BrushActors (或 *画刷*) 常用于快速设置场景原型，粗略构建出场景来测试游戏性。 |
| 骨架网格模型 | 一个带动画的网格物体或骨架网格物体，它的几何体可以发生变形，变形一般通过应用创建的及从外部3D动画用程序中导入的动画序列来完成。这些Actor通常用于类似于角色、活动的生物、及复杂的机器这样的物体；及用于任何需要变形或显示复杂运动的物体。这些Actor也经常同Matinee结合使用，来创建过场动画序列 |

| 光源实体 | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| 点光源   | 和现实世界中灯泡的工作原理类似，灯泡从灯泡的钨丝向各个方向发光。然而，为了获得更好的性能，点光源简化为仅从空间中的一个点向各个方向均匀地发光。 |
| 聚光灯   | 从锥形空间中的一个单独的点处发出光照。它为用户提供了两个锥体来塑造光源- **内锥角** 和 **外锥角** 。在 *内锥角* 中，光源达到最大亮度，形成一个亮盘。在而从内锥角到外锥角，光照会发生衰减，并在亮盘周围产生半影区（或者说是软阴影）。光源的半径定义了圆锥体的长度。<br />简单地讲，聚光源的工作原理同手电筒或舞台聚光灯类似。 |
| 定向光   | 模拟从一个无限远的源头处发出的光照。这意味着这个光源照射出阴影的效果都是平行的，从而使得它成了模拟太阳光的理想选择。定向光源在设置的时候可以选择三种移动设置的一种。 |

| 其他常见实体             | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 粒子发射器               | 是一种用于通过以平面粒子（相机朝向的平面）或网格物体的方式生成粒子来创建特效(比如烟雾、火焰、火花等)的Actor。粒子的实际行为定义在特殊的资源[粒子系统](http://api.unrealengine.com/CHN/Engine/Rendering/ParticleSystems/index.html) 中并由粒子系统进行控制，您可以在[内容浏览器](http://api.unrealengine.com/CHN/Engine/Content/Browser/index.html) 中创建粒子系统，在 [Cascade粒子编辑器](http://api.unrealengine.com/CHN/Engine/Rendering/ParticleSystems/Cascade/index.html) 中编辑粒子系统。 |
| 环境音效（AmbientSound） | 用于在世界中以 Sound Cue的形式播放音效。这些音效可以时循环播放的也可以是非循环播放的，可以具有空间化及衰减效果，但所有这些必须在SoundCue中进行设置，而没有暴露在环境音效actor本身上。 |
| 体积（Volume)            | 关卡中不可见的3D区域，都有其特定用途。如：<br />给玩家施加伤害<br />改变物理定律，在体积空间内可能会允许玩家悬浮，或者让玩家失重。<br />作为碰撞表面，阻止玩家进入该体积。<br />改变计算关卡光照或可见性的方式。 |
| 贴花（Decal）            | 用作小型特殊物体，如弹孔、血污                               |
| 摄像机                   |                                                              |

## 常用组件

| 组件                           | 作用                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| AI Perception AI感知           | 用于注册为 **AIPerceptionSystem** 中的刺激信号监听器，并可收集已注册的刺激信号。当组件获得新刺激信号 (batched) 时，将调用 **UpdatePerception** |
| Pawn NoiseEmitter Pawn噪声发射 | 追踪 **SensingComponents** 所使用的噪声事件数据以监听 Pawn。该组件用于存在于 Pawn 上或其控制器上。其在网络客户端上不进行任何操作。 |
| Pawn Sensing Pawn感知          | 可包含 Actor 的感知（即，视觉和听觉）设置及功能，允许 Actor 在游戏世界中看到/听到 Pawn。其在网络客户端上不进行任何操作。 |
|                                |                                                              |
| Audio 组件                     | 音频组件允许将 [Sound Wave](http://api.unrealengine.com/CHN/Engine/Audio/WAV/index.html) 或 [Sound Cue](http://api.unrealengine.com/CHN/Engine/Audio/Overview/index.html#soundcue) 添加为 Actor 的子对象，从而提供声源。<br />例如，如果您想要用粒子效果来表现关卡中着火的情景。当仅靠粒子效果就能表现出着火的视觉效果时，可加入一个音频组件作为它的子 Actor，以播放熊熊烈火的音频素材，则着火的效果会更加逼真。 |
|                                |                                                              |
| 摄像机组件                     | 摄像机组件可以让您添加一个摄像机视角作为 Actor 的子对象。如果 **ViewTarget** 是 **CameraActor**，或者 Actor 包含摄像机组件且它的 **bFindCameraComponentWhenViewTarget**选项设置为 True。<br />例如，如果在游戏过程中，您想要在关卡中[切换多个摄像机](http://api.unrealengine.com/CHN/Gameplay/HowTo/UsingCameras/Blueprints/index.html) 。通过使用 **SetViewTargetWithBlend** 和 CameraActor，您可在各摄像机之间进行切换，并使用在 CameraActor 中为各摄像机定义的属性（包括视野、角度或任何后处理效果等）。<br />**bTakeCameraControlWhenPossessed** 是可以为任何 **Pawn** 设置的相关属性，被 PlayerController 占有时，Pawn 会自动成为 ViewTarget。比如，如果您有多个想要切换的人物（以 Pawn 形式存在），且对每个人物都指派了各自的摄像机组件并提供了摄像机视角，则您想要在各人物之间进行切换时，可将各人物的 bTakeCameraControlWhenPossessed 设为 true，这样就可以使用各人物的摄像机组件了（可对每个摄像机组件定义各自的属性和设置）。 |
| Spring Arm（弹簧臂）           | 弹簧臂组件会努力与其子对象之间保持一个固定距离，但如果发生碰撞，就会使子对象收回，如果没有碰撞，则使之发生回弹。通常，弹簧臂组件用作“摄像机摇臂”，可防止玩家的跟拍摄像机在游戏时间中发生碰撞（没有弹簧臂组件，则摄像机组件将保持指定的固定距离，无论是可能会挡住它去路的对象，还是它所跟随的对象） |
|                                |                                                              |
| 定向光组件                     | 模拟了从无穷远的光源发射出的灯光。这也就是说，这种灯光所投射的所有阴影都是平行的，使其成为模拟阳光的最佳选择。 |
| 点光组件                       | 感觉上很像是现实世界中的灯泡，从灯泡的钨丝向着所有方向发射灯光。但是，为了提高运行性能，点光源组件被简化了，只从空间中的一个点均匀地向所有方向发射光线。 |
| Sky Light天空光                | 用于捕捉关卡中的远距离物体（距离大于 SkyDistanceThreshold 的所有物体），并将其作为灯光应用到场景中。这也就是说，天空的外观及其光线/反射将匹配。 |
| 聚光组件                       | 从锥形的单点发射出方向性光线。有一些设置可调节内锥角和外锥角，另外还有一些其他类型的光线设置，如强度、光线颜色和阴影设置。这种光线很适合作为手电筒，因为它可以定义内/外锥角半径。 |
|                                |                                                              |
| Character Movement角色移动     | 允许形象不使用物理刚体移动（走、跑、跳、飞、跌落和游泳）。 该组件专用于 **Characters**，任何其他类无法执行它。 |
| Projectile Movement抛射物移动  | 会更新另一个组件的位置。碰撞后弹跳以及朝着目标归位等行为由此类组件支持。 通常，原始 Actor 的根组件会被移动，但是，可能会选择另一个组件。主要模拟子弹、球等 |
| Rotating Movement旋转移动      | 指定旋转速率执行组件的连续旋转。（可选）也可围绕枢轴点偏置旋转。请记住，在移动过程中，无法进行碰撞测试。使用旋转移动组件的示例可以是飞机的螺旋桨、风车，甚至是一系列围绕太阳旋转的星球。 |
|                                |                                                              |
| Destructible 可摧毁组件        | 用于存放 Destructible Actor 的物理数据。在添加该组件作为子对象时，您必须指定要使用的 **Destructible Mesh** 资源。如果愿意，您也可以覆盖并指定 **Fracture Effects** 而非使用资源本身的 Fracture Effects。 |
| Physics Constraint物理约束     | 是一种能连接两个刚性物体的接合点。您可以借助该组件的各类参数来创建不同类型的接合点。<br />您可以创建悬摆型对象，如秋千、重沙袋或标牌，它们可以对世界中的物理作用做出响应，让玩家与组件进行互动 |
| Physics Handle物理句柄         | 用于“抓取”和移动物理对象，同时让您抓取的对象继续使用物理效果。这样的例子可能以“重力枪”的形式存在，此时您可以拾取和掉落物理对象 |
| Physics Thruster物理推进器     | 适用于沿着 X 轴负方向施加特定物理作用力的对象（例如，您所推动的方向上的 X 点）。推力组件使用连续作用力，而且能通过脚本来自动激活、一般激活或取消激活。<br />关于推力组件的示例可能以火箭的形式出现，它将持续施加作用力将火箭向上推（因为推力部分位于火箭下方）。通过使用 **Blocking Volumes**，您可以牵制一些受推力影响的组件动作。 |
| Radial Force 径向力            | 用于发出径向力或脉冲来影响物理对象或可摧毁对象。与 **PhysicsThrusterComponent** 不同，这类组件会施加“发射后不用管”类型的作用力，而且并不持续。<br />可以使用这类组件来推动被摧毁对象（如爆炸物）的碎片。使用 **RadialForceComponent** 指定作用力和方向，当对象被摧毁时，您可以像下面的图示那样，沿着特定方向将碎片向外“推” |
|                                |                                                              |
| Arrow                          | 是一个用直线渲染的简单箭头，用于指示对象应当遵循的朝向。在下面这个门的示例中，箭头指示了在场景中放置门的时候应当遵循的朝向（由于门可能被脚本指定为只能朝一个方向开启，此时应符合箭头的朝向）。 |
| Box                            | 是一个盒体，通常被用于简单碰撞（也可用作下面示例中的触发器）。<br />**BoxComponent** 被添加到火焰粒子效果周围，同时将碰撞设置指定为 **Generate Overlap Events**。当其他东西与这个盒体交叠时，将会触发一个事件，此时会执行一个脚本向与之交叠的 Actor 施加伤害。您也可以将 [Collision Response](http://api.unrealengine.com/CHN/Engine/Physics/Collision/index.html) 设置为 **BlockAll** 来避免所有 Actor 进入这个盒体（如果您希望防止其他东西进入火焰范围内）。 |
| Capsule                        | 是一个胶囊形状，也可用于简单碰撞（如下所示）或充当触发器。<br />在创建新的 **Character Blueprint** 时，会自动包含 **CapsuleComponent** 并为人物提供碰撞设置，从而避免其与世界中的对象交叉。**CapsuleComponent** 还能 **Generate Overlap Events** 或 **Generate Hit Events**，以便您提供脚本来指定何时发生这些事件。 |
| Sphere                         | 是可用于碰撞的球形组件（例如下面这些发生在抛射物周围的碰撞）。 |
| Spline                         | 可用于生成街道或复杂路径（作为其他组件的运动路线）           |
|                                |                                                              |
| Skeletal Mesh骨架网格组件      | 骨架网格模型（外观）具有一个复杂的骨架（互连骨骼），在其内部可以移动骨架网格模型的单个顶点来匹配当前播放的动画。 这使得 SkeletalMeshComponents 成为诸多情形下的理想之选，包括人物、生物、复杂机械或任何需要变形或展现复杂运动的情况。 |
| Static Mesh静态网格            | 是一个包含一组静态多边形的几何体，是在虚幻引擎 4 的场景中创建世界几何体所用的基本单位。除构建场景外，静态网格模型还能用于创建运动体（如门或电梯）、刚体物理对象、植物和地形修饰、程序化创建的建筑、游戏目标和许多其他的视觉元素。 |

### 渲染组件

| 组件                                    | 作用                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| Atmospheric Fog 大气雾                  | 用于创建雾化效果，如场景中的云或环境雾气。该组件拥有几项可调整的设置，可以影响此效果在关卡中的生成方式。对 **Decay Height** 设置（用于控制雾的浓度衰减高度，例如，较低的值可以让雾变浓，较高的值会让雾变稀，产生更少的散布）使用不同值的这类组件。有关详细信息 |
| Exponential Height Fog指数高度雾        | 用于创建雾化效果，而其浓度与雾的高度相关。在地图中较低的地方产生密度较大的雾，在较高的地方产生密度较小的雾。随着您增加高度，雾会进行平滑的转变，您不会看到明显的切换效果。指数型高度雾也提供了两种雾颜色，一种颜色用于面向主要定向光源(如果不存在景则径直向上)的半球体，另一种颜色用于相反方向的半球体。 |
| Billboard                               | 是一个会被渲染为始终朝向摄像机的 2D 贴图，其功能与 **ArrowComponent** 类似，可用于某种放置方法且能够轻松选取。<br />可创建类似光束薄雾效果 |
| Material Billboard                      | 是一个被渲染为始终朝向摄像机的 2D 材质。这类组件可用在 2D 草丛或树叶等情形中。我们并未使用静态网格模型来呈现生长中的草丛甚至单个草叶，而是利用 **MaterialBillboardComponent** 和一个材质来表现生长中的草，这样就无需使用草的 3D 象征，因为看板（billboard）将自动转动并朝向玩家，从而呈现出草的三维表象。 |
| Cable 绳缆组件                          | 可以将两个组件附加在一起，同时在它们之间渲染出一条连线。在这条连线上，您可以指定一个材质并定义参数来影响连线的显示方式。<br />假如您需要让玩家人物在绳索之类的东西上摆动，就可以使用这类组件。只要通过脚本将一个点附加到某个固定位置，并将另一个点附加到玩家人物，该人物便可以在绳索上摆动。 |
| Poseable Mesh姿态网格                   | 可自行控制骨骼变换                                           |
| Decal 贴花组件                          | 是一个被渲染到网格模型表面上的材质（一种适用于模型的“保险杠标贴”）。贴花组件可用于任何目的，如发射子弹时在墙上撞出的痕迹，车辆在道路上擦出的打滑印记，被击中时在地上溅出的血迹等 |
| Instanced Static Mesh实例化静态网格组件 | 可以高效渲染同一静态网格模型的多个实例。 这类组件尤其适用于程序化创建的场景或房间，因为它不会在场景中放置成百上千个 **Static Mesh Actors**，您只需放置一个 **Instanced Static Mesh** 并添加该静态网格模型（如地板或墙）的多个实例，性能负担也大大降低。 |
| Particle SYstem                         | 可以让您添加一个粒子发射器作为其他对象的子对象。添加 **ParticleSystemComponent** 可用于多种目的，例如，为想要摧毁的对象添加爆炸效果，或是为可以点燃的对象增加着火效果。通过添加这类组件到其他对象，您便可以在游戏过程中借助脚本访问和设置任何粒子效果参数（例如打开或关闭效果） |
| Post Process后期处理                    | 这类组件可以在某一场景应用了后处理设置时变换场景的色调。例如，假设您定义了一个默认的后处理设置并将其用于游戏，那么在玩家受到伤害（或丧命）时，您可以通过脚本将 **Scene Color Tint** 的设置改为黑色/白色色调。 |
| Scene Capture 2D 场景捕捉2D             | 用于从单一平面捕获场景“快照”并将其馈送给渲染目标。在捕获和指定 **Render Target** 贴图时，除其他设置外有一些设置可用于控制 **Field of View**。这样的示例包括在监视器上创建镜子（如下面所示）或安保摄像头视角的情形 |
| Scene Capture Cube 场景捕捉立方         | 用于从 6 个平面捕获场景“快照”并将其馈送给渲染目标。<br />在多数情况下，**SceneCapture2DComponent** 应当能满足大部分场景捕获需求，但在需要对环境进行 3D 捕获时，您可以使用这个组件。但在使用时应当留意，因为这会产生很大的性能消耗，只应当在绝对必要时使用。 |
| Spline Mesh 样条网格                    | 可用于拉伸和弯曲静态网格模型资源。使用 **SplineMeshesComponents** 时，您必须提供方位对应的向量，并提供样条曲线起点和终点的切线。 |
| Text Render 字体渲染                    | 可以用指定的字体渲染世界中的文本。其中包含与常用字体有关的属性，如 Scale、Alignment、Color 等。您可以使用该组件提示玩家您的场景中有一个复杂对象。<br />例如，假设您的场景中有一把椅子，玩家只要在靠近时按一个按键就能坐下。您可以添加一个包含必要提示的 **TextRenderComponent** 来执行就坐命令（关闭可见性），同时将一个 **BoxComponent** 用作触发器，用于在玩家进入时将文本的可见性设为 true |
| Vector Field矢量域                      | 用于引用 [**Vector Field**](http://api.unrealengine.com/CHN/Engine/Rendering/ParticleSystems/VectorFields/index.html) ，这是一种带有速度向量网格的 3D 容器，可用于确定 GPU 子画面的速度或加速度。 向量场可用于场景中的小规模效果（如强风粒子效果）和大规模效果（如暴雪）。另请参见 [**Local Vector Fields**](http://api.unrealengine.com/CHN/Resources/ContentExamples/EffectsGallery/2_A/index.html) 和 [**Global Vector Fields**](http://api.unrealengine.com/CHN/Resources/ContentExamples/EffectsGallery/2_B/index.html) 了解详细信息。 |

### 工具型组件

| 组件                               | 作用                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| Application Lifecycle 应用程序生命 | 用于从操作系统接收关于应用程序状态的通知（激活、挂起、终止等）。 |
| Child Actor                        | 在注册后可以生成一个 Actor，取消注册时则将其销毁。           |
| Scene组件                          | 拥有一个变换形式并支持附加特性，但没有渲染或碰撞功能。它可以作为一个“虚拟”组件放在层级结构中用来偏移其他组件。 |
| Widget组件                         | 本身是控件组件蓝图（Widget Blueprint）的一个 3D 实例，您可以在游戏世界中与它进行互动。 |



# 资源/内容管理

## 常见引擎内容

| 内容                     | 作用 |
| ------------------------ | ---- |
| 游戏关卡                 |      |
| 材质                     |      |
| 粒子系统                 |      |
| 过场动画序列             |      |
| 蓝图脚本/预制体          |      |
| 导航网格                 |      |
| 预计算光照信息           |      |
| 场景（关卡）光照         |      |
|                          |      |
| *外部导入资源内容*       |      |
| 静态网格物体（模型）     |      |
| 骨架网格物体（动作模型） |      |
| 骨架动画（动画）         |      |
| 材质                     |      |
| 声音                     |      |
| IES灯光信息              |      |
| 纹理                     |      |
| Nvidia APEX物理          |      |





# 引擎功能

## 渲染和图形

| 渲染技术                      | 作用                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| 延迟渲染Defferred Shading     | 将材质属性写入GBuffer，光照通过读入每像素材质属性并执行光照  |
| 光照路径Lighting path         | * 全动态，适用于可移动的光源<br />* 部分静态，适用于位置不动，但其他属性会改变的光源<br />* 全静态，适用于静态光源 |
| 半透明照明 Lit Translucency   | 其光照和着色都是单次的，这样可确保正确地与其他半透明物体混合，而多通道光照技巧则不能实现这种效果。它可以将阴影投影到不透明的世界及其自身，或其他半透明照明物体。 |
| 子表面着色Sub-surface shading | 适用于蜡、翡翠等看似不透明，但光在内部会散射的材质。这相对于一般表面渲染质量稍微低一些，但性能更高。 |
| GPU粒子 GPU Particles         | 使用硬件加速粒子模拟运算                                     |
| 矢量场 Vector Field           | 可对粒子运动产生统一影响。它可作为实体放置在世界中。         |
|                               |                                                              |
| 后期特效：                    |                                                              |
| 环境遮挡 Ambient Occlusion    | 是SSAO（屏幕空间环境遮挡）的一种实现方式，并且当前仅基于深度缓冲。即法线贴图细节或平滑组不会影响效果。此功能目前仅用于Ambient Cubemap |
| 环境立体图                    | 对整个场景光照应用立体贴图。此特效与材质被光照的位置无光。视角位置、材质粗糙度、材质表现发现被参与计算。 |
| Bloom 溢光                    | **光溢出** 是真实世界中的一种光照现象，该效果可以在中度的渲染开销下，为渲染出的图像增加更多的真实感。 当我们用裸眼看非常亮的对象并且背景非常暗时，就会看到这种光溢出现象。尽管比较亮的对象也会产生其它的效果（如条纹、镜头眩光），但是这里讨论的典型的光溢出特效并不包含其他效果。 由于我们的显示器（比如 TV、TFT……）通常不支持 HDR（高动态范围），所以实际上并不能渲染非常亮的对象。 取而代之的做法是，只是模拟以下的情况发生后的效果，比如光照在视网膜表面的散射，或者光照射到薄膜（薄膜表面散射），以及相机前方（乳白色玻璃滤镜）的效果。 这类效果并不总是完全在物理学上显示正确，但却能帮助表现对象的相对亮度，或给 LDR（低动态范围 Low Dynamic Range）图片增加真实感。 |
| Bloom Dirt Mask               | 通过使用贴图，在一些指定的屏幕区域是溢光更为明亮。可用于制作战争镜头或更加绚丽夺目的HDR特效或表达镜头缺陷感 |
| Eye Adaptation眼适应          | 或称自动曝光，重现从明亮环境进入黑暗环境（或相反）时所经历的效果。 |
| Lens Flare 镜头眩光           | 基于图像技术，会在镜头转向明亮物体时自动产生镜头的眩光效果。 |
| Tone Mapping 色调映射         | 使得渲染场景的颜色可以被转换或修改来得到不同的效果。这可以被用来制作诸如棕褐滤镜，或击中特效（例如红色闪光）等。 |
| Vignetee 晕影                 | 效果可以造成被渲染场景的亮度随距视角中心位置的距离增加而逐渐降低。 |

### 材质

是可以应用到网格物体上的资源，用它可控制场景的可视外观。从较高的层面上来说，可能最简单的方法就是把材质视为应用到一个物体的"描画"。但这种说法也会产生一点点误导，因为材质实际上定义了组成该物体所用的表面类型。您可以定义它的颜色、它的光泽度及您是否能看穿该物体等等。

用更为专业的术语来说，当穿过场景的光照接触到表面后，材质被用来计算该光照如何与该表面进行互动。这些计算是通过对材质的输入数据来完成的，而这些输入数据来自于一系列图像（贴图）以及数学表达式，以及材质本身所继承的不同属性设置。

在虚幻引擎中，材质由节点网络构建，每个节点包含一部分HLSL代码，处理特定的任务。

众知，颜色——数字图像——被分成4个基础通道：红，绿，蓝，透明。所有数字图片，每个像素，这些通道的值可用数值表示。材质的最典型工作即是基于特殊场合和数学公式简单操作这些值。

材质使用float值存储颜色值。即每个通道值范围为0..1,对应其他图形应用上的0..255。你可过载这些值，以适应特殊的行为。如，若将颜色给与材质的Emissive（产生光晕），超过1.0的值会增加光晕的亮度。

在材质中，纹理是简单图片，提供一系列基于像素的数据。这些数据可能是某对象的颜色、光泽、透明度或其他方面。有一种过时的想法，认为“添加纹理”是给游戏模型上色的过程。虽然创建纹理的过程仍然很关键，但我们应该将纹理看作材质的“元件”，而不是将它们本身视为最终成品，这一点很重要。

一个单一材质有可能用到几个不同的纹理贴图作为不同的目的效果。比如，一个简单的材质可能会有一个基础颜色的纹理贴图，一个高光纹理，一个法线贴图。除此以外，还有可能有保存在透明通道中的自发光贴图以及粗造度贴图。

可以发现，虽然这些可能都同时存在于一个贴图的布局中，但纹理贴图中的不同的颜色被用于不同的目的。

纹理一旦创建并导入虚幻引擎，就会通过特殊的材质表达式节点（ 例如 *纹理取样（Texture Sample）* 节点）引入到材质中。您可以在上文的硬木地板示例中看到这些内容。这些节点引用纹理资产，该资产存在于材质外部，可以在 **内容浏览器** 中单独找到。与某些 3D 应用程序不同，材质无法包含它自己的纹理。

材质的基本操作：

| 操作                                             | 作用                                                         |
| ------------------------------------------------ | ------------------------------------------------------------ |
| UI坐标动画Animate UI                             | 为材质添加运动的能力不可或缺，当您尝试重新创建诸如火焰、流水或烟雾之类的效果时尤其如此。UV 坐标动画或 UV 平移的含义是，水平 (U) 和/或垂直 (V) 移动纹理的 UV 坐标，以产生复杂动画的错觉。 在以下示例中，火焰纹理沿着 U（水平）方向平移，使火焰看起来像是在移动一样。（使用Panner平移）。UV 坐标动画是一种可以为材质引入运动效果的出色方法。 对于需要复杂运动的视觉效果（如烟雾或火焰），这种方法也极为有用。 但是，请记住，UV 坐标动画最适合于具有连续 UV 设置的对象。 网格 UV 坐标中的任何偏差在 UV 坐标动画时都会显现。 |
| 凹凸贴图偏移Bump Offset                          | **凹凸贴图偏移**（Bump Offset）贴图通过以创新的方式修改 UV 坐标来帮助强化纹素与对象表面的错位，从而营造出表面细节超出实际情况的错觉。就是通常所谓的“视差贴图”。BumpOffset（凹凸贴图偏移）表达式可以使材质产生深度错觉，而不需要额外的几何体。BumpOffset（凹凸贴图偏移）材质使用灰阶 *高度贴图* 来提供深度信息。高度贴图中的值越亮，材质的“凸出”效果越明显；当摄像机在表面上移动时，这些区域将产生视差（移位）。高度贴图中较暗的区域将显得“距离较远”，其移位程度最小。<br />使用“凹凸贴图偏移”（Bump Offset）材质表达式是一种非常有效的低成本方法，您可以采用这种方法为材质添加额外的深度信息，而无需添加额外的 3D 几何体。 但是，请记住，“凹凸贴图偏移”（Bump Offset）材质表达式仅提供额外深度信息的错觉，因此这种效果在以下情况下可能会失效/不起作用： 玩家/用户可能移动他们的摄像机，使其与应用了凹凸贴图偏移效果的表面平行。 |
| 对透明涂层添加双法线Dual Normals with Clear Coat | 透明涂层着色模型现在可以为透明涂层以下的表面添加第二法线贴图。这样可以更精确地为复杂的材质建模，如表面与透明涂层存在几何差异的碳纤维 |
| 彩色半透明阴影Colored Translucent Shadows        | 为场景注入一些颜色适合于许多应用，但最常用于彩绘玻璃窗等物品。“半透明阴影颜色”术语用于说明阴影在穿过对象时如何拾取对象的颜色（也称为 **传播**）。 穿过材质的光线量由材质的不透明度值（介于 0 与 1 之间）及投射到材质的光线量确定。 例如，如果不透明度设置为 0，那么材质的彩色阴影不会有光线传播。如果不透明值设置为 1，那么它将是完全不透明物。<br />有关彩色阴影需要牢记的最重要一点是，它 **仅** 支持 **静态光线**。 另外，您需要确保根据自己的设计需要，选择最佳的混合模式（半透明、递增法和调制）。 彩色阴影的应用十分广泛，并且，您可以根据项目的需要使用各种混合模式。 |
| 分层材质Layered Materials                        | 最终的分层材质会自动将雪置于对象的顶部表面，从而在两种材质之间有效地进行切换。材质之间的混合将总是检查顶部表面，这意味着即使您旋转对象，雪也总是停留在顶部。 |
| 细节纹理Detail Textures                          | 以非常近的距离查看材质时，您会注意到，材质中使用的纹理会细化为像素点，导致视觉效果欠佳。 为了解决此问题，您可以使用“细节纹理”，来帮助隐藏以非常近的距离查看材质时产生的纹理像素化。**细节纹理化** 通过引入叠加在对象原始漫射及法线贴图上的高度重复漫射及法线贴图组合，使纹理产生更加细腻的错觉。 这可以在近距离查看时产生优于正常的细节效果错觉。（DetailTexturing）<br />处理大型表面（例如地形）时，您将注意到，即使您所使用的纹理可以平铺，也会存在许多观看效果不佳的明显重复，从远距离查看时尤其如此。 为了解决此问题，我们可以在先前创建的细节材质的基础上进行构建，使其在距离摄像机较近时显示一个纹理，而在距离摄像机较远时显示另一个纹理。 这通常称为“基于距离的纹理混合”<br />细节纹理化是功能非常强大的工具，可以真正帮助您实现 3D 项目。 但是，就像所有其他功能强大的工具一样，您必须十分谨慎，确保这种强大的功能在您的掌控之下。 请记住，细节纹理化只能在一定程度上消除像素化。 允许玩家摄像机放大对象等行为可能会导致细节纹理化所实现的好处失效。 另外，请记住，添加细节纹理化可能会在材质中添加两个或两个以上额外的纹理查找操作，这可能会产生一些性能/内存问题，在移动平台上更是如此。 |
| 自发光                                           | 在项目开发过程中，可能会需要自发亮材质或发光材质。 在虚幻引擎 4 (UE4) 中，自发亮材质也称为自发光材质。 <br />放射性辉光（在 UE4 中称为“自发光材质”）为美工提供了一种非常有效而低成本的方法，可在材质实际未投射光线时产生其正在投射光线的错觉。 自发光材质通过允许美工将“自发光”（Emissive）输入的值提高到大于 1.0 来实现此效果，这将使材质进入 HDR 范围， 从而发出您注视非常明亮的光源时可能会看到的高光效果。<br />自发光材质是自发亮材质，这表示它们可以与照亮和不照亮明暗处理模型配合使用。 但是，自发光材质应该尽可能使用不照亮明暗处理模型，因为这将产生渲染成本较低的着色器。 在这两种不同的明暗处理模型之间，渲染自发光的方式并没有视觉上的差别。 所以，应尽可能使用成本较低的不照亮阴影模式。<br />您可以将纹理、数字或这两者的组合输入到“自发光”（Emissive）输入。实际上，您输入的内容视材质的需要而定。如果自发光材质仅用于模拟光线， 那么应该使用数值，而不是纹理。但是，如果要模拟对象上的光线，那么应使用纹理作为自发光蒙板，因为您可以在蒙板纹理中准确定义 应该照亮的部分。<br />在虚幻引擎 4 中，可以在材质中使用“自发光”（Emissive）输入来帮助照亮环境。要启用此功能，您只需确保为 材质中的“自发光”（Emissive）输入提供输入，然后将材质放在环境中的某个对象上。构建光线后，您应该会看到，环境中的静态对象现在看起来像是被 材质的“自发光”（Emissive）输入照亮一样。<br />向任何材质添加放射性辉光是一种低成本而成效的方法，这样可以模拟光源，而不必添加任何新光线。 但是，请记住，使用放射性辉光时，放射性辉光不会像普通光线那样照亮动态对象（例如人物）。 另外，如果辉光过强，请记住调整“后期处理体积”（Post Process Volume）的“高光”（Bloom）设置。 |
| 菲涅尔效果Fresnel                                | 创建电影时，您常常需要更好地凸显人物的轮廓。这种照明技术通常称为“边缘照明”，它 涉及添加额外的光线，以帮助更好地区分人物边缘与背景。虽然这种技术对于电影来说效果相当不错，但是，向任何 3D 场景添加额外的光线也意味着 额外增加复杂性，这种复杂性有可能会迅速变得难以管理。虚幻引擎 4 (UE4) 提供了一种解决方案，即，允许美工使用人物的材质模拟相同的基本效果。 如此一来，美工就会对该效果的外观拥有更大的控制权，甚至可以使用这种效果向不照亮对象添加照明以提高性能，等等。<br />**菲涅耳效果** 术语用来描述您所看到的光线如何根据您的查看角度以不同强度反射。 例如，如果您站在一个池子旁边直视池底，那么将看不到水中的大量反光。 当您开始移动头部，使得池水水面与您的视平线越来越平行时，您会开始注意到水中的反光越来越多。<br />“菲涅耳效果”（Fresnel）会检查表面法线是否与摄像机垂直。 如果它与摄像机垂直，那么将出现菲涅耳效果。在平滑的球体上，这意味着只会在对象边缘产生菲涅耳效果。 但是，引入法线贴图时，我们将表面法线更改为不再平滑，从而使菲涅耳效果可在表面法线平滑时正常情况下 不会出现该效果的位置出现。<br />“菲涅耳效果”（Fresnel）的工作方式决定了它不仅可实现边缘照明，还可完成其他任务。 以下是使用“菲涅耳效果”（Fresnel）节点来完成除边缘照明以外的其他任务的一些示例。<br />向材质添加菲涅耳效果是一种很不错的方法，这有助于更好地凸显人物轮廓，或帮助显示能量护盾特效。 请记住，菲涅耳效果的实现以查看角度和表面法线为基础，因此，如果您想为菲涅耳效果增加一些有趣的细节，请尝试使用其中有少许随机噪声的法线贴图。 并且，请不要忘记，您可使用“菲涅耳效果”（Fresnel）材质表达式来帮助在两个不同输入之间进行混合，这样很容易实现火焰或烟雾等视觉效果。 |
| 人体皮肤                                         | 让人体皮肤在渲染后正确显示是一个非常复杂的主题，没有一个获得正确结果的完美解决方案。 为此，请将以下信息视为您的工作的 *起始点*，因为要获得逼真的图像，需要完成大量的工作。 这是因为我们的眼睛经过非常良好的训练，能够探测到人体面部很细微的细节。 正确做到这一点非常具有挑战性，但一旦精通了工具，就可以将它们应用于许多其他情况。<br />首先需要了解的一件事是，从非常远的距离很难察觉到表面散射效果。 这意味着最好让纹理的底色在从远处查看时显得正常。 您也可以使用灰度纹理使底色变深，并使用高光效果（由于散射导致）使皮肤呈现一个较好的整体外观。 还可以添加一些矢量和标量控件来调整皮肤的颜色及活力，以帮助您进一步微调，从而获得想要的外观<br />对于皮肤，最好从 0.4 左右的粗糙度常量值开始，并从此值进行微调。 请记住，实际值取决于影调范围/距离、年龄以及您试图模拟的皮肤的干湿程度。 与其他纹理不同，我们明确地想要纹理映射看起来不一样。请注意，MIP 越小，就具有越明亮的灰度值，这意味着材质转变为更粗燥的材质。 还要注意，可以将此纹理放入另一个纹理的通道中（这样可减少纹理查找和纹理内存）。 理想情况下，此纹理应该与法线贴图纹理具有相同的分辨率。<br />皮肤的高光值设置为值 **0.35**。 使用数字 0.35 是因为此数字是从真实世界测量出的高光值转换为我们使用的范围后得出的。用于面部的法线贴图应该只包含有关皱纹的细节。毛孔细节应该通过平铺纹理来完成，因为这样可以得到更好的结果。将对象的法线贴图与细节法线贴图合并时，请确保使用材质函数 BlendAngleCorrectedNormals 进行合并，因为您将获得更好的结果。 显示参数以调整法线贴图的混合同样非常重要。您可以采用细节法线贴图值，对其 Z 分量增加特定标量值，然后标准化。 这样就可以将一个普通的法线贴图转变成一个平面细节法线贴图。由于皮肤的不同区域具有不同的阴影属性，最好将粗糙度与对象映射（非拼贴）的纹理结合起来。 由于细节法线贴图会导致粗糙度随着距离增大而增加，我们必须做出补偿。我们还需要从多个影调范围/视野距离验证阴影，以确保无论距离摄像头多远，阴影看起来都正常。现代的实时渲染技术使用基于像素的光照计算来产生阴影。通常，这会得到十分高质量的结果，但适用于非常精细的法线贴图。使用 Mip 贴图可以避免闪光并得到较好的性能，但 Mip 贴图对于法线贴图表现不佳，这是因为较低的 MIP 中的细节根本不存在，并且表面会显得比应有效果明亮得多。为了抵消这种效果，我们可以相应地调整粗糙度。这并不会捕获屈光参差的细节，但对于无方向的特性，这是一个不错的近似值。<br />透明度输入控制所发生的次表面散射量。 值 1 或纯白意味着应全力进行次表面散射。 值 0 或纯黑意味着不应发生次表面散射。<br />让皮肤拥有毛孔是获得逼真皮肤过程中非常重要的一个细节。 然而，由于毛孔需要非常细致，因此，仅仅通过向基本法线贴图中添加毛孔很难达到所需的质量。 将毛孔作为单独的拼贴纹理添加不仅使它们更加突出，还可方便对它们进行调整。<br/>由于此着色器中毛孔拼贴细节的变化，已使用 TexCoord 材质表达式乘以标量参数，以便我们能够在材质实例内部获得所需的毛孔。由于毛孔略低于表面区域，因此从切线角查看时，实际上很难看到它们。 我们可以模拟当调整被观察平面的角度时，毛孔逐渐变淡的现象。<br />次表面概况用来使皮肤显得逼真。 要在材质中使用次表面概况，您只需要提供材质或材质实例以及要使用的次表面概况。<br />设置皮肤并使其正确渲染是一个较长的复杂过程，需要花一些时间才能获得满意的结果。 请记住，本指南应该只用来帮助您在设置皮肤时指明正确的方向。 如果您发现使用与此处提供的设置略有不同的设置能够获得您想要的结果，这是正常的。 再次强调，上述信息并不是您在设置皮肤时必须严格遵循的规则，而应该被视为可以遵循的准则。 |
| 实例材质                                         | 材质实例化是这样的一种方法：创建单个材质（称为“父材质”），然后将其作为基础来创建外观不同的各种材质。 为了实现这种灵活性，“材质实例化”使用“继承”概念。 继承无非意味着将父代的属性提供给子代。“材质实例化”是一个强大的工具，可以用于项目的所有方面。 这包括帮助对武器和道具添加一些变化，以及帮助美工更好地利用材质。 材质实例切实有助于简化并统一在项目中创建及使用材质的方式。 |



在 GPU 上，顶点着色器针对每个顶点运行，而像素着色器针对每个像素运行。在虚幻引擎 4 中，几乎所有材质节点都针对每个像素来运行。虽然 **UV 坐标（UV Coordinate）**节点可以是顶点或像素着色器的一部分，但是 **定制 UV** 功能仅在顶点着色器中运行，与在像素着色器中运行相同计算相比，这可以提高性能。这是一种提高速度的绝佳方法，即使是仅仅平铺纹理也是如此。虽然系统并未限制可以对 UV 运行的数学运算，但是结果将依赖于网格的铺嵌。

* 非线性数学运算

  一般规则是，如果要执行的计算使用了常量（摄像机位置、时间、矢量参数，等等）或者随每个顶点的属性而线性变化，那么在顶点着色器中执行该工作的结果与在像素着色器中执行该工作相同。线性变化表示仅限将会产生直线（而非曲线）的运算，例如乘法和加法。使用正弦、余弦或 `length（长度）`之类的运算对变量进行开方将产生非线性方程式。

  非线性数学运算是否会产生期望的结果将取决于其所应用于的网格的细节。相反，如果此数学运算直接输入到纹理中，那么它将在像素着色器中进行求值，从而产生相同的结果，而与网格细节无关。

* 线性数学运算

  按某个参数来调整 UV 比例（将 UV 与该参数相乘）在这两种数学运算中以相同方式工作。UV 是依赖于每个顶点的属性，而比例调整是线性运算。下列各图显示执行线性运算时，在顶点着色器中计算的“定制 UV”（CustomizedUV）将产生与在像素着色器中执行同一计算相同的效果。

* 性能

  在大多数情况下，顶点数目显著少于像素数目，因此将数学运算移至顶点着色器可大幅提高性能。请注意，如果您要建立多边形数目非常高的网格，或者不将 LOD 用于多边形数目较高的网格，那么额外的顶点着色器工作可能会成为瓶颈。这是因为，无论网格是在 4 个像素的距离之外，还是填满屏幕，顶点着色器工作都相同。

* 移动设备

  在移动设备上，**任何以任意方式处理纹理坐标的纹理取样都采用慢速路径**。这称为 *从属* 纹理提取。通过使用定制 UV 输入，您仍可实现平铺或全局空间纹理贴图，同时保持所有的纹理提取 *独立*，这是快速路径。

  另外，移动设备上像素着色器中的所有内容都是使用半精度浮点值进行求值。这会导致对纹理坐标执行像素着色器数学运算时，产生块状纹理及其他一些失真。但是，定制 UV 输入使用全精度，因此避免了此问题。

#### 基于物理的着色

## UI设计器

## 骨骼动画系统

## 序列帧编辑器


## 音频

## 行为树

## 环境查询系统

## 物理模拟

## 开放世界工具

## 户外风景地形

## 植被实例化网格

## 流式关卡

## 层级式LOD

## 蓝图样条

## 过场动画和电影艺术

## 媒体框架

## 性能和剖析

## 打包和烘焙游戏

## 回放系统

## 网络和多人

## 2D开发

## 资源和包

## 坐标系空间术语

## 派生数据缓存

## 目录结构

## 分布式

## 重定向

## 截屏

## 多人协作

## 内置插件

