I""<p>“数据结构+算法=程序”，这一句话深入人心，如果是程序员，那肯定对此话有深刻的理解。确实如此，整个应用程序的组成，无外乎两个元素：数据结构，算法。</p>

<p>算法是计算方式，是函数，是方法，是解决问题的步骤。算法在程序中，以函数为基本表现形式。</p>

<p>数据结构是存储数据的形式。在编码过程中，基本上就是寻找合理的数据结构，并编写对其操作的函数。</p>

<p>在不同的编程语言中，有些把常用的数据结构已经内置在语言中，有些则是以标准库的形式提供。</p>

<p>研究数据结构，需要从数据的逻辑结构和物理结构两方面着手。</p>

<p>逻辑结构：反应数据元素之间的逻辑关系，即前后元素之间的关系。数据的逻辑结构有以下几种：</p>
<ul>
  <li>线性结构：即元素存在一对一的相互关系</li>
  <li>树形结构：即元素存在一对多的相互关系</li>
  <li>集合：即元素同属一个集合，它们之间没有互相联系</li>
  <li>图形结构：即元素存在多对多的相互关系</li>
</ul>

<p>物理结构：指在计算机中存储的形式。数据的物理结构有以下几种：</p>
<ul>
  <li>顺序存储：数据顺序存储，元素与元素为邻接关系。</li>
  <li>链式存储：元素与元素通过链相连。</li>
  <li>索引存储：元素通过索引表一一对应。这会在数据元素之外，新建索引表。</li>
</ul>

<p>数据结构的算法，往往涉及元素的这样几个操作：增、删、改、查。</p>
<ul>
  <li>增：往数据结构中添加元素。添加的位置可是：头、中、尾。</li>
  <li>删：从数据结构中删除元素。删除的位置可是：头、中、尾。</li>
  <li>查：从数据结构中查找满足条件的元素。查找的方式有这样几种：顺序、随机。</li>
  <li>改：改变数据结构中某个或某些元素，改的前提是查，查到才能改。</li>
</ul>

<h2 id="常用结构">常用结构：</h2>
<ul>
  <li>数组：顺序数据结构。通常内置于编程语言中，是线性结构，常采用顺序存储方式。
    <ul>
      <li>元组：是非同种类型的数组。</li>
    </ul>
  </li>
  <li>栈：是只能一端插入和删除的结构，先进后出。是线性结构，可采用顺序和链式存储方式，常采用顺序存储。常用于undo类似的任务中。</li>
  <li>队列：从前面出，后面进的结构，先进先出。是线性结构，可采用顺序和链式存储，但常采用链式存储。
    <ul>
      <li>循环队列：将队列头和尾相连</li>
    </ul>
  </li>
  <li>列表：有节点概念。是线性结构，常采用链式存储方式。
    <ul>
      <li>双向链表：每个节点都存储了前、后两个节点信息。</li>
    </ul>
  </li>
  <li>集合：是集合结构，可采用顺序和索引存储。</li>
  <li>树：有根、叶概念。是非线性结构，常采用链式存储。
    <ul>
      <li>红黑树：是自平衡二叉树。</li>
      <li>二/四/八叉树：每个节点对应有不同数量的子节点。常用于空间分割。</li>
    </ul>
  </li>
  <li>图：有节点集合、边集合概念。是图形结构，可采用链式和索引存储。</li>
  <li>映射表：具映射关系的表。可是线性和树形结构，可采用链式和索引存储。
    <ul>
      <li>散列表：索引是由数据的散列值而来，当要查找数据时，直接计算散列值即可获取到数据。</li>
      <li>多重映射表：一个索引有多个对应值</li>
    </ul>
  </li>
</ul>

<h2 id="在c中的实现">在C#中的实现</h2>
<p>C#中的数据结构，都在System.Collections命名空间下。在C#中存在这样几个接口：</p>
<ul>
  <li>ICollection：定义了方法<code class="highlighter-rouge">Add</code>,<code class="highlighter-rouge">Clear</code>,<code class="highlighter-rouge">Contains</code>,<code class="highlighter-rouge">Remove</code>和属性<code class="highlighter-rouge">Count</code>。<code class="highlighter-rouge">Contains</code>，<code class="highlighter-rouge">Remove</code>内部使用<code class="highlighter-rouge">IEquatable</code>相等比较器。</li>
  <li>IEnumerator：枚举器。里面定义了一个属性Current，表示当前枚举迭代至某一元素位置。</li>
  <li>IList：定义了方法<code class="highlighter-rouge">[]</code>,<code class="highlighter-rouge">IndexOf</code>,<code class="highlighter-rouge">Insert</code>,<code class="highlighter-rouge">RemoveAt</code>。可以索引访问、取索引、插入元素、删除指定索引处元素等。<code class="highlighter-rouge">IndexOf</code>内部会进行相等比较。</li>
</ul>

<p>在System.Collections.Generic下，有以下数据结构：</p>
<ul>
  <li>List<T>:列表。使用它的类型，需要实现`IEquatable`接口。如果要进行排序、查找，则要实现`IComparable`接口。</T></li>
  <li>Stack<T>：栈。</T></li>
  <li>LinkedList<T>：双向链表。</T></li>
  <li>Directionary&lt;K,V&gt;：键值对表，哈希表。</li>
  <li>HashSet<T>:散列集合。</T></li>
  <li>Queue<T>：队列。</T></li>
</ul>

<p>在C#中，常见的容器都是继承于<code class="highlighter-rouge">ICollection&lt;T&gt;</code>，而它本身是可枚举的<code class="highlighter-rouge">IEnumerable</code>，可通过foreach进行迭代。foreach内部工作使用枚举器，枚举器的使用前提是：集合保持不变。如果集合发生更改，枚举将会失效且不可恢复，并下个迭代中<code class="highlighter-rouge">MoveNext</code>使会引发<code class="highlighter-rouge">无效操作</code>异常。在对集合进行枚举的过程中，枚举器没有对集合的独占访问权。</p>

<p>一个很客观的例子，删除集合中所有重复数据。代码可能很快就来：</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">a</span> <span class="k">in</span> <span class="n">collection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">collection</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>但这个代码是有问题的，首先，Remove自身内部有遍历，会进行相等判断，移除第一个相等的元素；其次，foreach使用，枚举器，如果集合发生改变，那么foreach所依赖的枚举器将会不稳定，内部的<code class="highlighter-rouge">MoveNext</code>会访问一个已被移除的节点，迭代会失效。</p>

<p>所以，可以如下：</p>
<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">collection</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">collection</span><span class="p">.</span><span class="nf">RemoveAt</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="在c中的实现-1">在C++中的实现</h2>
<p>C++中的常用数据结构，放在std命名空间，包括：</p>
<ul>
  <li>vector<T>:动态数组</T></li>
  <li>stack<T>:栈</T></li>
  <li>queue<T>：队列</T></li>
  <li>priority_queue<T>:优先级队列</T></li>
  <li>map&lt;K,V&gt;:键值对映射表</li>
  <li>multi_map&lt;K,V&gt;:多重映射表，一个键可有多个值</li>
  <li>unordered_map&lt;K,V&gt;:哈希表。键为值的哈希值</li>
  <li>unordered_multimap&lt;K,V&gt;:多重哈希表</li>
  <li>set<T>：集合</T></li>
  <li>multiset<T>：多重集合</T></li>
  <li>unordered_set<T>：哈希集合</T></li>
  <li>unordered_multiset<T>：多重哈希集合</T></li>
</ul>

:ET